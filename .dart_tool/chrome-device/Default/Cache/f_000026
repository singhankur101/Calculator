define(['dart_sdk', 'packages/vector_math/vector_math.dart'], (function load__packages__math_expressions__math_expressions_dart(dart_sdk, packages__vector_math__vector_math$46dart) {
  'use strict';
  const core = dart_sdk.core;
  const math = dart_sdk.math;
  const _internal = dart_sdk._internal;
  const _interceptors = dart_sdk._interceptors;
  const _js_helper = dart_sdk._js_helper;
  const collection = dart_sdk.collection;
  const dart = dart_sdk.dart;
  const dartx = dart_sdk.dartx;
  const vector_math = packages__vector_math__vector_math$46dart.vector_math;
  var math_expressions = Object.create(dart.library);
  var $hashCode = dartx.hashCode;
  var $isInfinite = dartx.isInfinite;
  var $compareTo = dartx.compareTo;
  var $toInt = dartx.toInt;
  var $toString = dartx.toString;
  var $toDouble = dartx.toDouble;
  var $_get = dartx._get;
  var $length = dartx.length;
  var $map = dartx.map;
  var $toList = dartx.toList;
  var $fold = dartx.fold;
  var $singleWhere = dartx.singleWhere;
  var $join = dartx.join;
  var $isEmpty = dartx.isEmpty;
  var $trim = dartx.trim;
  var $removeLast = dartx.removeLast;
  var $add = dartx.add;
  var $last = dartx.last;
  var $_set = dartx._set;
  var $replaceAll = dartx.replaceAll;
  var $runes = dartx.runes;
  var $containsKey = dartx.containsKey;
  var $isNotEmpty = dartx.isNotEmpty;
  var $where = dartx.where;
  var $first = dartx.first;
  var $remove = dartx.remove;
  dart._checkModuleNullSafetyMode(false);
  var T = {
    ListOfExpression: () => (T.ListOfExpression = dart.constFn(core.List$(math_expressions.Expression)))(),
    ExpressionToExpression: () => (T.ExpressionToExpression = dart.constFn(dart.fnType(math_expressions.Expression, [math_expressions.Expression])))(),
    boolAndExpressionTobool: () => (T.boolAndExpressionTobool = dart.constFn(dart.fnType(core.bool, [core.bool, math_expressions.Expression])))(),
    JSArrayOfVariable: () => (T.JSArrayOfVariable = dart.constFn(_interceptors.JSArray$(math_expressions.Variable)))(),
    VariableTobool: () => (T.VariableTobool = dart.constFn(dart.fnType(core.bool, [math_expressions.Variable])))(),
    JSArrayOfExpression: () => (T.JSArrayOfExpression = dart.constFn(_interceptors.JSArray$(math_expressions.Expression)))(),
    IdentityMapOfString$TokenType: () => (T.IdentityMapOfString$TokenType = dart.constFn(_js_helper.IdentityMap$(core.String, math_expressions.TokenType)))(),
    JSArrayOfToken: () => (T.JSArrayOfToken = dart.constFn(_interceptors.JSArray$(math_expressions.Token)))(),
    EvaluationTypeL: () => (T.EvaluationTypeL = dart.constFn(dart.legacy(math_expressions.EvaluationType)))(),
    IdentityMapOfString$Expression: () => (T.IdentityMapOfString$Expression = dart.constFn(_js_helper.IdentityMap$(core.String, math_expressions.Expression)))(),
    LinkedHashSetOfMathFunction: () => (T.LinkedHashSetOfMathFunction = dart.constFn(collection.LinkedHashSet$(math_expressions.MathFunction)))(),
    MathFunctionTobool: () => (T.MathFunctionTobool = dart.constFn(dart.fnType(core.bool, [math_expressions.MathFunction])))()
  };
  var T$Eval = Object.assign({
    _: () => T$Eval
  }, T);
  var S = {
    _: () => S
  };
  var S$Eval = Object.assign({
    _: () => S$Eval
  }, S);
  const CT = Object.create({
    _: () => (C, CT)
  });
  dart.defineLazy(CT, {
    get C0() {
      return C[0] = dart.const({
        __proto__: math_expressions.TokenType.prototype,
        [TokenType_function]: false,
        [TokenType_operator]: false,
        [TokenType_leftAssociative]: true,
        [TokenType_priority]: 10,
        [TokenType_value]: "VAL"
      });
    },
    get C1() {
      return C[1] = dart.const({
        __proto__: math_expressions.TokenType.prototype,
        [TokenType_function]: false,
        [TokenType_operator]: false,
        [TokenType_leftAssociative]: true,
        [TokenType_priority]: 10,
        [TokenType_value]: "VAR"
      });
    },
    get C2() {
      return C[2] = dart.const({
        __proto__: math_expressions.TokenType.prototype,
        [TokenType_function]: false,
        [TokenType_operator]: true,
        [TokenType_leftAssociative]: false,
        [TokenType_priority]: 3,
        [TokenType_value]: "UNMINUS"
      });
    },
    get C3() {
      return C[3] = dart.const({
        __proto__: math_expressions.TokenType.prototype,
        [TokenType_function]: false,
        [TokenType_operator]: true,
        [TokenType_leftAssociative]: true,
        [TokenType_priority]: 1,
        [TokenType_value]: "PLUS"
      });
    },
    get C4() {
      return C[4] = dart.const({
        __proto__: math_expressions.TokenType.prototype,
        [TokenType_function]: false,
        [TokenType_operator]: true,
        [TokenType_leftAssociative]: true,
        [TokenType_priority]: 1,
        [TokenType_value]: "MINUS"
      });
    },
    get C5() {
      return C[5] = dart.const({
        __proto__: math_expressions.TokenType.prototype,
        [TokenType_function]: false,
        [TokenType_operator]: true,
        [TokenType_leftAssociative]: true,
        [TokenType_priority]: 2,
        [TokenType_value]: "TIMES"
      });
    },
    get C6() {
      return C[6] = dart.const({
        __proto__: math_expressions.TokenType.prototype,
        [TokenType_function]: false,
        [TokenType_operator]: true,
        [TokenType_leftAssociative]: true,
        [TokenType_priority]: 2,
        [TokenType_value]: "DIV"
      });
    },
    get C7() {
      return C[7] = dart.const({
        __proto__: math_expressions.TokenType.prototype,
        [TokenType_function]: false,
        [TokenType_operator]: true,
        [TokenType_leftAssociative]: true,
        [TokenType_priority]: 2,
        [TokenType_value]: "MOD"
      });
    },
    get C8() {
      return C[8] = dart.const({
        __proto__: math_expressions.TokenType.prototype,
        [TokenType_function]: false,
        [TokenType_operator]: true,
        [TokenType_leftAssociative]: false,
        [TokenType_priority]: 4,
        [TokenType_value]: "POW"
      });
    },
    get C9() {
      return C[9] = dart.const({
        __proto__: math_expressions.TokenType.prototype,
        [TokenType_function]: true,
        [TokenType_operator]: false,
        [TokenType_leftAssociative]: true,
        [TokenType_priority]: 5,
        [TokenType_value]: "EFUNC"
      });
    },
    get C10() {
      return C[10] = dart.const({
        __proto__: math_expressions.TokenType.prototype,
        [TokenType_function]: true,
        [TokenType_operator]: false,
        [TokenType_leftAssociative]: true,
        [TokenType_priority]: 5,
        [TokenType_value]: "LOG"
      });
    },
    get C11() {
      return C[11] = dart.const({
        __proto__: math_expressions.TokenType.prototype,
        [TokenType_function]: true,
        [TokenType_operator]: false,
        [TokenType_leftAssociative]: true,
        [TokenType_priority]: 5,
        [TokenType_value]: "LN"
      });
    },
    get C12() {
      return C[12] = dart.const({
        __proto__: math_expressions.TokenType.prototype,
        [TokenType_function]: true,
        [TokenType_operator]: false,
        [TokenType_leftAssociative]: true,
        [TokenType_priority]: 5,
        [TokenType_value]: "SQRT"
      });
    },
    get C13() {
      return C[13] = dart.const({
        __proto__: math_expressions.TokenType.prototype,
        [TokenType_function]: true,
        [TokenType_operator]: false,
        [TokenType_leftAssociative]: true,
        [TokenType_priority]: 5,
        [TokenType_value]: "ROOT"
      });
    },
    get C14() {
      return C[14] = dart.const({
        __proto__: math_expressions.TokenType.prototype,
        [TokenType_function]: true,
        [TokenType_operator]: false,
        [TokenType_leftAssociative]: true,
        [TokenType_priority]: 5,
        [TokenType_value]: "SIN"
      });
    },
    get C15() {
      return C[15] = dart.const({
        __proto__: math_expressions.TokenType.prototype,
        [TokenType_function]: true,
        [TokenType_operator]: false,
        [TokenType_leftAssociative]: true,
        [TokenType_priority]: 5,
        [TokenType_value]: "COS"
      });
    },
    get C16() {
      return C[16] = dart.const({
        __proto__: math_expressions.TokenType.prototype,
        [TokenType_function]: true,
        [TokenType_operator]: false,
        [TokenType_leftAssociative]: true,
        [TokenType_priority]: 5,
        [TokenType_value]: "TAN"
      });
    },
    get C17() {
      return C[17] = dart.const({
        __proto__: math_expressions.TokenType.prototype,
        [TokenType_function]: true,
        [TokenType_operator]: false,
        [TokenType_leftAssociative]: true,
        [TokenType_priority]: 5,
        [TokenType_value]: "ASIN"
      });
    },
    get C18() {
      return C[18] = dart.const({
        __proto__: math_expressions.TokenType.prototype,
        [TokenType_function]: true,
        [TokenType_operator]: false,
        [TokenType_leftAssociative]: true,
        [TokenType_priority]: 5,
        [TokenType_value]: "ACOS"
      });
    },
    get C19() {
      return C[19] = dart.const({
        __proto__: math_expressions.TokenType.prototype,
        [TokenType_function]: true,
        [TokenType_operator]: false,
        [TokenType_leftAssociative]: true,
        [TokenType_priority]: 5,
        [TokenType_value]: "ATAN"
      });
    },
    get C20() {
      return C[20] = dart.const({
        __proto__: math_expressions.TokenType.prototype,
        [TokenType_function]: true,
        [TokenType_operator]: false,
        [TokenType_leftAssociative]: true,
        [TokenType_priority]: 5,
        [TokenType_value]: "ABS"
      });
    },
    get C21() {
      return C[21] = dart.const({
        __proto__: math_expressions.TokenType.prototype,
        [TokenType_function]: true,
        [TokenType_operator]: false,
        [TokenType_leftAssociative]: true,
        [TokenType_priority]: 5,
        [TokenType_value]: "CEIL"
      });
    },
    get C22() {
      return C[22] = dart.const({
        __proto__: math_expressions.TokenType.prototype,
        [TokenType_function]: true,
        [TokenType_operator]: false,
        [TokenType_leftAssociative]: true,
        [TokenType_priority]: 5,
        [TokenType_value]: "FLOOR"
      });
    },
    get C23() {
      return C[23] = dart.const({
        __proto__: math_expressions.TokenType.prototype,
        [TokenType_function]: true,
        [TokenType_operator]: false,
        [TokenType_leftAssociative]: true,
        [TokenType_priority]: 5,
        [TokenType_value]: "SGN"
      });
    },
    get C24() {
      return C[24] = dart.const({
        __proto__: math_expressions.TokenType.prototype,
        [TokenType_function]: false,
        [TokenType_operator]: false,
        [TokenType_leftAssociative]: true,
        [TokenType_priority]: -1,
        [TokenType_value]: "LBRACE"
      });
    },
    get C25() {
      return C[25] = dart.const({
        __proto__: math_expressions.TokenType.prototype,
        [TokenType_function]: false,
        [TokenType_operator]: false,
        [TokenType_leftAssociative]: true,
        [TokenType_priority]: -1,
        [TokenType_value]: "RBRACE"
      });
    },
    get C26() {
      return C[26] = dart.const({
        __proto__: math_expressions.TokenType.prototype,
        [TokenType_function]: false,
        [TokenType_operator]: false,
        [TokenType_leftAssociative]: true,
        [TokenType_priority]: -1,
        [TokenType_value]: "SEPAR"
      });
    },
    get C27() {
      return C[27] = dart.const({
        __proto__: math_expressions.EvaluationType.prototype,
        [_name$]: "EvaluationType.REAL",
        index: 0
      });
    },
    get C28() {
      return C[28] = dart.const({
        __proto__: math_expressions.EvaluationType.prototype,
        [_name$]: "EvaluationType.VECTOR",
        index: 1
      });
    },
    get C29() {
      return C[29] = dart.const({
        __proto__: math_expressions.EvaluationType.prototype,
        [_name$]: "EvaluationType.INTERVAL",
        index: 2
      });
    },
    get C30() {
      return C[30] = dart.constList([C[27] || CT.C27, C[28] || CT.C28, C[29] || CT.C29], T.EvaluationTypeL());
    }
  }, false);
  var C = Array(31).fill(void 0);
  var I = [
    "file:///C:/Users/ashwa/OneDrive/Desktop/flutter/.pub-cache/hosted/pub.dartlang.org/math_expressions-2.1.1/lib/src/algebra.dart",
    "package:math_expressions/math_expressions.dart",
    "file:///C:/Users/ashwa/OneDrive/Desktop/flutter/.pub-cache/hosted/pub.dartlang.org/math_expressions-2.1.1/lib/src/expression.dart",
    "file:///C:/Users/ashwa/OneDrive/Desktop/flutter/.pub-cache/hosted/pub.dartlang.org/math_expressions-2.1.1/lib/src/functions.dart",
    "file:///C:/Users/ashwa/OneDrive/Desktop/flutter/.pub-cache/hosted/pub.dartlang.org/math_expressions-2.1.1/lib/src/parser.dart",
    "file:///C:/Users/ashwa/OneDrive/Desktop/flutter/.pub-cache/hosted/pub.dartlang.org/math_expressions-2.1.1/lib/src/evaluator.dart"
  ];
  math_expressions.Point3 = class Point3 extends vector_math.Vector3 {
    static new(x, y, z) {
      let t0;
      if (x == null) dart.nullFailed(I[0], 7, 25, "x");
      if (y == null) dart.nullFailed(I[0], 7, 35, "y");
      if (z == null) dart.nullFailed(I[0], 7, 45, "z");
      t0 = new math_expressions.Point3.zero();
      return (() => {
        t0.setValues(x, y, z);
        return t0;
      })();
    }
    static vec(other) {
      let t0;
      if (other == null) dart.nullFailed(I[0], 11, 30, "other");
      t0 = new math_expressions.Point3.zero();
      return (() => {
        t0.setFrom(other);
        return t0;
      })();
    }
    ['+'](v) {
      if (v == null) dart.nullFailed(I[0], 19, 29, "v");
      return math_expressions.Point3.new(dart.notNull(this.x) + dart.notNull(v.x), dart.notNull(this.y) + dart.notNull(v.y), dart.notNull(this.z) + dart.notNull(v.z));
    }
    ['-'](p2) {
      if (p2 == null) dart.nullFailed(I[0], 24, 30, "p2");
      return vector_math.Vector3.new(dart.notNull(this.x) - dart.notNull(p2.x), dart.notNull(this.y) - dart.notNull(p2.y), dart.notNull(this.z) - dart.notNull(p2.z));
    }
    _negate() {
      return math_expressions.Point3.new(-dart.notNull(this.x), -dart.notNull(this.y), -dart.notNull(this.z));
    }
    _equals(o) {
      if (o == null) return false;
      if (math_expressions.Point3.is(o)) {
        return this.x == o.x && this.y == o.y && this.z == o.z;
      } else {
        return false;
      }
    }
    lerp(p2, coeff) {
      if (p2 == null) dart.nullFailed(I[0], 43, 22, "p2");
      if (coeff == null) dart.nullFailed(I[0], 43, 30, "coeff");
      return math_expressions.Point3.new(dart.notNull(this.x) * dart.notNull(coeff) + dart.notNull(p2.x) * (1 - dart.notNull(coeff)), dart.notNull(this.y) * dart.notNull(coeff) + dart.notNull(p2.y) * (1 - dart.notNull(coeff)), dart.notNull(this.z) * dart.notNull(coeff) + dart.notNull(p2.z) * (1 - dart.notNull(coeff)));
    }
    toVec4() {
      return vector_math.Vector4.new(this.x, this.y, this.z, 1.0);
    }
    get hashCode() {
      let result = 17;
      result = 37 * result + dart.hashCode(this.x);
      result = 37 * result + dart.hashCode(this.y);
      result = 37 * result + dart.hashCode(this.z);
      return result;
    }
    toString() {
      return dart.str(this.x) + "," + dart.str(this.y) + "," + dart.str(this.z);
    }
  };
  (math_expressions.Point3.zero = function() {
    math_expressions.Point3.__proto__.zero.call(this);
    ;
  }).prototype = math_expressions.Point3.prototype;
  dart.addTypeTests(math_expressions.Point3);
  dart.addTypeCaches(math_expressions.Point3);
  dart.setMethodSignature(math_expressions.Point3, () => ({
    __proto__: dart.getMethods(math_expressions.Point3.__proto__),
    '+': dart.fnType(math_expressions.Point3, [vector_math.Vector3]),
    _negate: dart.fnType(math_expressions.Point3, []),
    lerp: dart.fnType(math_expressions.Point3, [math_expressions.Point3, core.num]),
    toVec4: dart.fnType(vector_math.Vector4, [])
  }));
  dart.setLibraryUri(math_expressions.Point3, I[1]);
  dart.defineExtensionMethods(math_expressions.Point3, ['_equals', 'toString']);
  dart.defineExtensionAccessors(math_expressions.Point3, ['hashCode']);
  var min$ = dart.privateName(math_expressions, "Interval.min");
  var max$ = dart.privateName(math_expressions, "Interval.max");
  var _emptySet = dart.privateName(math_expressions, "_emptySet");
  var _min = dart.privateName(math_expressions, "_min");
  var _max = dart.privateName(math_expressions, "_max");
  math_expressions.Interval = class Interval extends core.Object {
    get min() {
      return this[min$];
    }
    set min(value) {
      this[min$] = value;
    }
    get max() {
      return this[max$];
    }
    set max(value) {
      this[max$] = value;
    }
    static empty() {
      return math_expressions.Interval._emptyInterval;
    }
    ['+'](i) {
      if (i == null) dart.nullFailed(I[0], 115, 32, "i");
      if (dart.test(this.isEmpty()) || dart.test(i.isEmpty())) {
        return math_expressions.Interval.empty();
      } else {
        return new math_expressions.Interval.new(dart.notNull(this.min) + dart.notNull(i.min), dart.notNull(this.max) + dart.notNull(i.max));
      }
    }
    _negate() {
      if (dart.test(this.isEmpty())) {
        return math_expressions.Interval.empty();
      } else {
        return new math_expressions.Interval.new(-dart.notNull(this.max), -dart.notNull(this.min));
      }
    }
    ['-'](i) {
      if (i == null) dart.nullFailed(I[0], 137, 32, "i");
      if (dart.test(this.isEmpty()) || dart.test(i.isEmpty())) {
        return math_expressions.Interval.empty();
      } else {
        return new math_expressions.Interval.new(dart.notNull(this.min) - dart.notNull(i.max), dart.notNull(this.max) - dart.notNull(i.min));
      }
    }
    ['*'](i) {
      if (i == null) dart.nullFailed(I[0], 148, 32, "i");
      if (dart.test(this.isEmpty()) || dart.test(i.isEmpty())) return math_expressions.Interval.empty();
      let min = this[_min](dart.notNull(this.min) * dart.notNull(i.min), dart.notNull(this.min) * dart.notNull(i.max), dart.notNull(this.max) * dart.notNull(i.min), dart.notNull(this.max) * dart.notNull(i.max));
      let max = this[_max](dart.notNull(this.min) * dart.notNull(i.min), dart.notNull(this.min) * dart.notNull(i.max), dart.notNull(this.max) * dart.notNull(i.min), dart.notNull(this.max) * dart.notNull(i.max));
      return new math_expressions.Interval.new(min, max);
    }
    ['/'](i) {
      if (i == null) dart.nullFailed(I[0], 162, 32, "i");
      if (dart.test(this.isEmpty()) || dart.test(i.isEmpty())) return math_expressions.Interval.empty();
      if (dart.test(i.containsZero())) {
        if (!dart.test(this.isPositive())) {
          if (i.min === 0 && i.max === 0) {
            return math_expressions.Interval.empty();
          }
          if (dart.notNull(i.min) < dart.notNull(i.max) && i.max === 0) {
            return new math_expressions.Interval.new(dart.notNull(this.max) / dart.notNull(i.min), 1 / 0);
          }
          if (dart.notNull(i.min) < dart.notNull(i.max) && i.min === 0) {
            return new math_expressions.Interval.new(-1 / 0, dart.notNull(this.max) / dart.notNull(i.max));
          }
        }
        if (dart.test(this.containsZero())) {
          return new math_expressions.Interval.new(-1 / 0, 1 / 0);
        }
        if (dart.notNull(this.max) > 0) {
          if (i.min === 0 && i.max === 0) {
            return math_expressions.Interval.empty();
          }
          if (dart.notNull(i.min) < dart.notNull(i.max) && i.max === 0) {
            return new math_expressions.Interval.new(-1 / 0, dart.notNull(this.min) / dart.notNull(i.min));
          }
          if (dart.notNull(i.min) < dart.notNull(i.max) && i.min === 0) {
            return new math_expressions.Interval.new(dart.notNull(this.min) / dart.notNull(i.max), 1 / 0);
          }
        }
        dart.throw(new core.ArgumentError.new("Can not divide by 0"));
      }
      return this['*'](new math_expressions.Interval.new(1.0 / dart.notNull(i.max), 1.0 / dart.notNull(i.min)));
    }
    _equals(i) {
      if (i == null) return false;
      return math_expressions.Interval.is(i) && this.min == i.min && this.max == i.max;
    }
    ['<'](i) {
      if (i == null) dart.nullFailed(I[0], 225, 28, "i");
      return dart.notNull(this.min) < dart.notNull(i.min) && dart.notNull(this.max) < dart.notNull(i.max);
    }
    ['<='](i) {
      if (i == null) dart.nullFailed(I[0], 230, 29, "i");
      return dart.notNull(this.min) <= dart.notNull(i.min) && dart.notNull(this.max) <= dart.notNull(i.max);
    }
    ['>'](i) {
      if (i == null) dart.nullFailed(I[0], 235, 28, "i");
      return dart.notNull(this.min) > dart.notNull(i.min) && dart.notNull(this.max) > dart.notNull(i.max);
    }
    ['>='](i) {
      if (i == null) dart.nullFailed(I[0], 240, 29, "i");
      return dart.notNull(this.min) >= dart.notNull(i.min) && dart.notNull(this.max) >= dart.notNull(i.max);
    }
    glb(i) {
      if (i == null) dart.nullFailed(I[0], 243, 25, "i");
      return new math_expressions.Interval.new(math.min(core.num, this.min, i.min), math.min(core.num, this.max, i.max));
    }
    lub(i) {
      if (i == null) dart.nullFailed(I[0], 247, 25, "i");
      return new math_expressions.Interval.new(math.max(core.num, this.min, i.min), math.max(core.num, this.max, i.max));
    }
    includes(i) {
      if (i == null) dart.nullFailed(I[0], 254, 26, "i");
      return dart.notNull(this.min) <= dart.notNull(i.min) && dart.notNull(i.max) <= dart.notNull(this.max);
    }
    contains(element) {
      if (element == null) dart.nullFailed(I[0], 261, 21, "element");
      return dart.notNull(this.min) <= dart.notNull(element) && dart.notNull(element) <= dart.notNull(this.max);
    }
    containsZero() {
      return dart.notNull(this.min) <= 0 && 0 <= dart.notNull(this.max);
    }
    isPositive() {
      return dart.notNull(this.min) >= 0;
    }
    isBound() {
      return !this.min[$isInfinite] && !this.max[$isInfinite];
    }
    isEmpty() {
      return this[_emptySet];
    }
    [_min](a, b, c, d) {
      if (a == null) dart.nullFailed(I[0], 276, 16, "a");
      if (b == null) dart.nullFailed(I[0], 276, 23, "b");
      if (c == null) dart.nullFailed(I[0], 276, 30, "c");
      if (d == null) dart.nullFailed(I[0], 276, 37, "d");
      return math.min(core.num, math.min(core.num, a, b), math.min(core.num, c, d));
    }
    [_max](a, b, c, d) {
      if (a == null) dart.nullFailed(I[0], 280, 16, "a");
      if (b == null) dart.nullFailed(I[0], 280, 23, "b");
      if (c == null) dart.nullFailed(I[0], 280, 30, "c");
      if (d == null) dart.nullFailed(I[0], 280, 37, "d");
      return math.max(core.num, math.max(core.num, a, b), math.max(core.num, c, d));
    }
    length() {
      return dart.notNull(this.max) - dart.notNull(this.min);
    }
    toString() {
      return "[" + dart.str(this.min) + "," + dart.str(this.max) + "]";
    }
    get hashCode() {
      let result = 17;
      result = 37 * result + dart.hashCode(this.min);
      result = 37 * result + dart.hashCode(this.max);
      return result;
    }
    compareTo(other) {
      math_expressions.Interval.as(other);
      if (other == null) dart.nullFailed(I[0], 298, 26, "other");
      if (dart.test(this['<'](other))) return -1;
      return dart.test(this['>'](other)) ? 1 : 0;
    }
  };
  (math_expressions.Interval.new = function(min, max) {
    if (min == null) dart.nullFailed(I[0], 101, 17, "min");
    if (max == null) dart.nullFailed(I[0], 101, 27, "max");
    this[min$] = min;
    this[max$] = max;
    this[_emptySet] = false;
    ;
  }).prototype = math_expressions.Interval.prototype;
  (math_expressions.Interval._empty = function() {
    this[min$] = 0 / 0;
    this[max$] = 0 / 0;
    this[_emptySet] = true;
    ;
  }).prototype = math_expressions.Interval.prototype;
  dart.addTypeTests(math_expressions.Interval);
  dart.addTypeCaches(math_expressions.Interval);
  math_expressions.Interval[dart.implements] = () => [core.Comparable$(math_expressions.Interval)];
  dart.setMethodSignature(math_expressions.Interval, () => ({
    __proto__: dart.getMethods(math_expressions.Interval.__proto__),
    '+': dart.fnType(math_expressions.Interval, [math_expressions.Interval]),
    _negate: dart.fnType(math_expressions.Interval, []),
    '-': dart.fnType(math_expressions.Interval, [math_expressions.Interval]),
    '*': dart.fnType(math_expressions.Interval, [math_expressions.Interval]),
    '/': dart.fnType(math_expressions.Interval, [math_expressions.Interval]),
    '<': dart.fnType(core.bool, [math_expressions.Interval]),
    '<=': dart.fnType(core.bool, [math_expressions.Interval]),
    '>': dart.fnType(core.bool, [math_expressions.Interval]),
    '>=': dart.fnType(core.bool, [math_expressions.Interval]),
    glb: dart.fnType(math_expressions.Interval, [math_expressions.Interval]),
    lub: dart.fnType(math_expressions.Interval, [math_expressions.Interval]),
    includes: dart.fnType(core.bool, [math_expressions.Interval]),
    contains: dart.fnType(core.bool, [core.num]),
    containsZero: dart.fnType(core.bool, []),
    isPositive: dart.fnType(core.bool, []),
    isBound: dart.fnType(core.bool, []),
    isEmpty: dart.fnType(core.bool, []),
    [_min]: dart.fnType(core.num, [core.num, core.num, core.num, core.num]),
    [_max]: dart.fnType(core.num, [core.num, core.num, core.num, core.num]),
    length: dart.fnType(core.num, []),
    compareTo: dart.fnType(core.int, [dart.nullable(core.Object)]),
    [$compareTo]: dart.fnType(core.int, [dart.nullable(core.Object)])
  }));
  dart.setLibraryUri(math_expressions.Interval, I[1]);
  dart.setFieldSignature(math_expressions.Interval, () => ({
    __proto__: dart.getFields(math_expressions.Interval.__proto__),
    min: dart.fieldType(core.num),
    max: dart.fieldType(core.num),
    [_emptySet]: dart.finalFieldType(core.bool)
  }));
  dart.defineExtensionMethods(math_expressions.Interval, ['_equals', 'toString', 'compareTo']);
  dart.defineExtensionAccessors(math_expressions.Interval, ['hashCode']);
  dart.defineLazy(math_expressions.Interval, {
    /*math_expressions.Interval._emptyInterval*/get _emptyInterval() {
      return new math_expressions.Interval._empty();
    }
  }, false);
  var _toExpression = dart.privateName(math_expressions, "_toExpression");
  var _isNumber = dart.privateName(math_expressions, "_isNumber");
  math_expressions.Expression = class Expression extends core.Object {
    ['+'](exp) {
      if (exp == null) dart.nullFailed(I[2], 32, 36, "exp");
      return new math_expressions.Plus.new(this, exp);
    }
    ['-'](exp) {
      if (exp == null) dart.nullFailed(I[2], 35, 36, "exp");
      return new math_expressions.Minus.new(this, exp);
    }
    ['*'](exp) {
      if (exp == null) dart.nullFailed(I[2], 38, 36, "exp");
      return new math_expressions.Times.new(this, exp);
    }
    ['/'](exp) {
      if (exp == null) dart.nullFailed(I[2], 41, 36, "exp");
      return new math_expressions.Divide.new(this, exp);
    }
    ['%'](exp) {
      if (exp == null) dart.nullFailed(I[2], 44, 36, "exp");
      return new math_expressions.Modulo.new(this, exp);
    }
    ['^'](exp) {
      if (exp == null) dart.nullFailed(I[2], 47, 36, "exp");
      return new math_expressions.Power.new(this, exp);
    }
    _negate() {
      return new math_expressions.UnaryMinus.new(this);
    }
    simplify() {
      return this;
    }
    [_toExpression](arg) {
      if (math_expressions.Expression.is(arg)) {
        return arg;
      }
      if (typeof arg == 'number') {
        return new math_expressions.Number.new(arg);
      }
      if (typeof arg == 'string') {
        return new math_expressions.Variable.new(arg);
      }
      dart.throw(new core.ArgumentError.new(dart.str(arg) + " is not a valid expression!"));
    }
    [_isNumber](exp, value = 0) {
      if (exp == null) dart.nullFailed(I[2], 101, 29, "exp");
      if (value == null) dart.nullFailed(I[2], 101, 39, "value");
      if (math_expressions.Literal.is(exp) && dart.test(exp.isConstant())) {
        return dart.equals(exp.getConstantValue(), value);
      }
      return false;
    }
  };
  (math_expressions.Expression.new = function() {
    ;
  }).prototype = math_expressions.Expression.prototype;
  dart.addTypeTests(math_expressions.Expression);
  dart.addTypeCaches(math_expressions.Expression);
  dart.setMethodSignature(math_expressions.Expression, () => ({
    __proto__: dart.getMethods(math_expressions.Expression.__proto__),
    '+': dart.fnType(math_expressions.Expression, [math_expressions.Expression]),
    '-': dart.fnType(math_expressions.Expression, [math_expressions.Expression]),
    '*': dart.fnType(math_expressions.Expression, [math_expressions.Expression]),
    '/': dart.fnType(math_expressions.Expression, [math_expressions.Expression]),
    '%': dart.fnType(math_expressions.Expression, [math_expressions.Expression]),
    '^': dart.fnType(math_expressions.Expression, [math_expressions.Expression]),
    _negate: dart.fnType(math_expressions.Expression, []),
    simplify: dart.fnType(math_expressions.Expression, []),
    [_toExpression]: dart.fnType(math_expressions.Expression, [dart.dynamic]),
    [_isNumber]: dart.fnType(core.bool, [math_expressions.Expression], [core.num])
  }));
  dart.setLibraryUri(math_expressions.Expression, I[1]);
  var __BinaryOperator_first = dart.privateName(math_expressions, "_#BinaryOperator#first");
  var __BinaryOperator_first_isSet = dart.privateName(math_expressions, "_#BinaryOperator#first#isSet");
  var __BinaryOperator_second = dart.privateName(math_expressions, "_#BinaryOperator#second");
  var __BinaryOperator_second_isSet = dart.privateName(math_expressions, "_#BinaryOperator#second#isSet");
  math_expressions.BinaryOperator = class BinaryOperator extends math_expressions.Expression {
    get first() {
      let t0;
      return dart.test(this[__BinaryOperator_first_isSet]) ? (t0 = this[__BinaryOperator_first], t0) : dart.throw(new _internal.LateError.fieldNI("first"));
    }
    set first(t0) {
      if (t0 == null) dart.nullFailed(I[2], 113, 25, "null");
      if (dart.test(this[__BinaryOperator_first_isSet]))
        dart.throw(new _internal.LateError.fieldAI("first"));
      else {
        this[__BinaryOperator_first_isSet] = true;
        this[__BinaryOperator_first] = t0;
      }
    }
    get second() {
      let t1;
      return dart.test(this[__BinaryOperator_second_isSet]) ? (t1 = this[__BinaryOperator_second], t1) : dart.throw(new _internal.LateError.fieldNI("second"));
    }
    set second(t1) {
      if (t1 == null) dart.nullFailed(I[2], 113, 32, "null");
      if (dart.test(this[__BinaryOperator_second_isSet]))
        dart.throw(new _internal.LateError.fieldAI("second"));
      else {
        this[__BinaryOperator_second_isSet] = true;
        this[__BinaryOperator_second] = t1;
      }
    }
  };
  (math_expressions.BinaryOperator.new = function(first, second) {
    this[__BinaryOperator_first] = null;
    this[__BinaryOperator_first_isSet] = false;
    this[__BinaryOperator_second] = null;
    this[__BinaryOperator_second_isSet] = false;
    this.first = this[_toExpression](first);
    this.second = this[_toExpression](second);
  }).prototype = math_expressions.BinaryOperator.prototype;
  (math_expressions.BinaryOperator.raw = function(first, second) {
    if (first == null) dart.nullFailed(I[2], 128, 27, "first");
    if (second == null) dart.nullFailed(I[2], 128, 39, "second");
    this[__BinaryOperator_first] = null;
    this[__BinaryOperator_first_isSet] = false;
    this[__BinaryOperator_second] = null;
    this[__BinaryOperator_second_isSet] = false;
    this[__BinaryOperator_first_isSet] = true;
    this[__BinaryOperator_first] = first;
    this[__BinaryOperator_second_isSet] = true;
    this[__BinaryOperator_second] = second;
    ;
  }).prototype = math_expressions.BinaryOperator.prototype;
  dart.addTypeTests(math_expressions.BinaryOperator);
  dart.addTypeCaches(math_expressions.BinaryOperator);
  dart.setGetterSignature(math_expressions.BinaryOperator, () => ({
    __proto__: dart.getGetters(math_expressions.BinaryOperator.__proto__),
    first: math_expressions.Expression,
    second: math_expressions.Expression
  }));
  dart.setSetterSignature(math_expressions.BinaryOperator, () => ({
    __proto__: dart.getSetters(math_expressions.BinaryOperator.__proto__),
    first: math_expressions.Expression,
    second: math_expressions.Expression
  }));
  dart.setLibraryUri(math_expressions.BinaryOperator, I[1]);
  dart.setFieldSignature(math_expressions.BinaryOperator, () => ({
    __proto__: dart.getFields(math_expressions.BinaryOperator.__proto__),
    [__BinaryOperator_first]: dart.fieldType(dart.nullable(math_expressions.Expression)),
    [__BinaryOperator_first_isSet]: dart.fieldType(core.bool),
    [__BinaryOperator_second]: dart.fieldType(dart.nullable(math_expressions.Expression)),
    [__BinaryOperator_second_isSet]: dart.fieldType(core.bool)
  }));
  var __UnaryOperator_exp = dart.privateName(math_expressions, "_#UnaryOperator#exp");
  var __UnaryOperator_exp_isSet = dart.privateName(math_expressions, "_#UnaryOperator#exp#isSet");
  math_expressions.UnaryOperator = class UnaryOperator extends math_expressions.Expression {
    get exp() {
      let t2;
      return dart.test(this[__UnaryOperator_exp_isSet]) ? (t2 = this[__UnaryOperator_exp], t2) : dart.throw(new _internal.LateError.fieldNI("exp"));
    }
    set exp(t2) {
      if (t2 == null) dart.nullFailed(I[2], 133, 25, "null");
      if (dart.test(this[__UnaryOperator_exp_isSet]))
        dart.throw(new _internal.LateError.fieldAI("exp"));
      else {
        this[__UnaryOperator_exp_isSet] = true;
        this[__UnaryOperator_exp] = t2;
      }
    }
  };
  (math_expressions.UnaryOperator.new = function(exp) {
    this[__UnaryOperator_exp] = null;
    this[__UnaryOperator_exp_isSet] = false;
    this.exp = this[_toExpression](exp);
  }).prototype = math_expressions.UnaryOperator.prototype;
  (math_expressions.UnaryOperator.raw = function(exp) {
    if (exp == null) dart.nullFailed(I[2], 147, 26, "exp");
    this[__UnaryOperator_exp] = null;
    this[__UnaryOperator_exp_isSet] = false;
    this[__UnaryOperator_exp_isSet] = true;
    this[__UnaryOperator_exp] = exp;
    ;
  }).prototype = math_expressions.UnaryOperator.prototype;
  dart.addTypeTests(math_expressions.UnaryOperator);
  dart.addTypeCaches(math_expressions.UnaryOperator);
  dart.setGetterSignature(math_expressions.UnaryOperator, () => ({
    __proto__: dart.getGetters(math_expressions.UnaryOperator.__proto__),
    exp: math_expressions.Expression
  }));
  dart.setSetterSignature(math_expressions.UnaryOperator, () => ({
    __proto__: dart.getSetters(math_expressions.UnaryOperator.__proto__),
    exp: math_expressions.Expression
  }));
  dart.setLibraryUri(math_expressions.UnaryOperator, I[1]);
  dart.setFieldSignature(math_expressions.UnaryOperator, () => ({
    __proto__: dart.getFields(math_expressions.UnaryOperator.__proto__),
    [__UnaryOperator_exp]: dart.fieldType(dart.nullable(math_expressions.Expression)),
    [__UnaryOperator_exp_isSet]: dart.fieldType(core.bool)
  }));
  math_expressions.UnaryMinus = class UnaryMinus extends math_expressions.UnaryOperator {
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[2], 165, 28, "toVar");
      return new math_expressions.UnaryMinus.new(this.exp.derive(toVar));
    }
    simplify() {
      let simplifiedOp = this.exp.simplify();
      if (math_expressions.UnaryMinus.is(simplifiedOp)) {
        return simplifiedOp.exp;
      }
      if (dart.test(this[_isNumber](simplifiedOp, 0))) {
        return simplifiedOp;
      }
      return new math_expressions.UnaryMinus.new(simplifiedOp);
    }
    evaluate(type, context) {
      if (type == null) dart.nullFailed(I[2], 190, 35, "type");
      if (context == null) dart.nullFailed(I[2], 190, 54, "context");
      return dart.dsend(this.exp.evaluate(type, context), '_negate', []);
    }
    toString() {
      return "(-" + dart.str(this.exp) + ")";
    }
  };
  (math_expressions.UnaryMinus.new = function(exp) {
    math_expressions.UnaryMinus.__proto__.new.call(this, exp);
    ;
  }).prototype = math_expressions.UnaryMinus.prototype;
  dart.addTypeTests(math_expressions.UnaryMinus);
  dart.addTypeCaches(math_expressions.UnaryMinus);
  dart.setMethodSignature(math_expressions.UnaryMinus, () => ({
    __proto__: dart.getMethods(math_expressions.UnaryMinus.__proto__),
    derive: dart.fnType(math_expressions.Expression, [core.String]),
    evaluate: dart.fnType(dart.dynamic, [math_expressions.EvaluationType, math_expressions.ContextModel])
  }));
  dart.setLibraryUri(math_expressions.UnaryMinus, I[1]);
  dart.defineExtensionMethods(math_expressions.UnaryMinus, ['toString']);
  math_expressions.Plus = class Plus extends math_expressions.BinaryOperator {
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[2], 211, 28, "toVar");
      return new math_expressions.Plus.new(this.first.derive(toVar), this.second.derive(toVar));
    }
    simplify() {
      let firstOp = this.first.simplify();
      let secondOp = this.second.simplify();
      if (dart.test(this[_isNumber](firstOp, 0))) {
        return secondOp;
      }
      if (dart.test(this[_isNumber](secondOp, 0))) {
        return firstOp;
      }
      if (math_expressions.UnaryMinus.is(secondOp)) {
        return firstOp['-'](secondOp.exp);
      }
      return new math_expressions.Plus.new(firstOp, secondOp);
    }
    evaluate(type, context) {
      if (type == null) dart.nullFailed(I[2], 242, 35, "type");
      if (context == null) dart.nullFailed(I[2], 242, 54, "context");
      return dart.dsend(this.first.evaluate(type, context), '+', [this.second.evaluate(type, context)]);
    }
    toString() {
      return "(" + dart.str(this.first) + " + " + dart.str(this.second) + ")";
    }
  };
  (math_expressions.Plus.new = function(first, second) {
    math_expressions.Plus.__proto__.new.call(this, first, second);
    ;
  }).prototype = math_expressions.Plus.prototype;
  dart.addTypeTests(math_expressions.Plus);
  dart.addTypeCaches(math_expressions.Plus);
  dart.setMethodSignature(math_expressions.Plus, () => ({
    __proto__: dart.getMethods(math_expressions.Plus.__proto__),
    derive: dart.fnType(math_expressions.Expression, [core.String]),
    evaluate: dart.fnType(dart.dynamic, [math_expressions.EvaluationType, math_expressions.ContextModel])
  }));
  dart.setLibraryUri(math_expressions.Plus, I[1]);
  dart.defineExtensionMethods(math_expressions.Plus, ['toString']);
  math_expressions.Minus = class Minus extends math_expressions.BinaryOperator {
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[2], 263, 28, "toVar");
      return new math_expressions.Minus.new(this.first.derive(toVar), this.second.derive(toVar));
    }
    simplify() {
      let firstOp = this.first.simplify();
      let secondOp = this.second.simplify();
      if (dart.test(this[_isNumber](secondOp, 0))) {
        return firstOp;
      }
      if (dart.test(this[_isNumber](firstOp, 0))) {
        return secondOp._negate();
      }
      if (math_expressions.UnaryMinus.is(secondOp)) {
        return firstOp['+'](secondOp.exp);
      }
      return new math_expressions.Minus.new(firstOp, secondOp);
    }
    evaluate(type, context) {
      if (type == null) dart.nullFailed(I[2], 294, 35, "type");
      if (context == null) dart.nullFailed(I[2], 294, 54, "context");
      return dart.dsend(this.first.evaluate(type, context), '-', [this.second.evaluate(type, context)]);
    }
    toString() {
      return "(" + dart.str(this.first) + " - " + dart.str(this.second) + ")";
    }
  };
  (math_expressions.Minus.new = function(first, second) {
    math_expressions.Minus.__proto__.new.call(this, first, second);
    ;
  }).prototype = math_expressions.Minus.prototype;
  dart.addTypeTests(math_expressions.Minus);
  dart.addTypeCaches(math_expressions.Minus);
  dart.setMethodSignature(math_expressions.Minus, () => ({
    __proto__: dart.getMethods(math_expressions.Minus.__proto__),
    derive: dart.fnType(math_expressions.Expression, [core.String]),
    evaluate: dart.fnType(dart.dynamic, [math_expressions.EvaluationType, math_expressions.ContextModel])
  }));
  dart.setLibraryUri(math_expressions.Minus, I[1]);
  dart.defineExtensionMethods(math_expressions.Minus, ['toString']);
  math_expressions.Times = class Times extends math_expressions.BinaryOperator {
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[2], 315, 28, "toVar");
      return new math_expressions.Plus.new(new math_expressions.Times.new(this.first, this.second.derive(toVar)), new math_expressions.Times.new(this.first.derive(toVar), this.second));
    }
    simplify() {
      let firstOp = this.first.simplify();
      let secondOp = this.second.simplify();
      let tempResult = null;
      let negative = false;
      if (math_expressions.UnaryMinus.is(firstOp)) {
        firstOp = firstOp.exp;
        negative = !negative;
      }
      if (math_expressions.UnaryMinus.is(secondOp)) {
        secondOp = secondOp.exp;
        negative = !negative;
      }
      if (dart.test(this[_isNumber](firstOp, 0))) {
        return firstOp;
      }
      if (dart.test(this[_isNumber](firstOp, 1))) {
        tempResult = secondOp;
      }
      if (dart.test(this[_isNumber](secondOp, 0))) {
        return secondOp;
      }
      if (dart.test(this[_isNumber](secondOp, 1))) {
        tempResult = firstOp;
      }
      if (tempResult == null) {
        tempResult = new math_expressions.Times.new(firstOp, secondOp);
        return negative ? tempResult._negate() : tempResult;
      }
      return negative ? new math_expressions.UnaryMinus.new(tempResult) : tempResult;
    }
    evaluate(type, context) {
      let t3;
      if (type == null) dart.nullFailed(I[2], 371, 35, "type");
      if (context == null) dart.nullFailed(I[2], 371, 54, "context");
      let firstEval = this.first.evaluate(type, context);
      let secondEval = this.second.evaluate(type, context);
      if (type == math_expressions.EvaluationType.VECTOR) {
        if (typeof secondEval == 'number') {
        } else {
          let $eval = (t3 = dart.dsend(firstEval, 'clone', []), (() => {
            dart.dsend(t3, 'multiply', [secondEval]);
            return t3;
          })());
          return $eval;
        }
      }
      return dart.dsend(firstEval, '*', [secondEval]);
    }
    toString() {
      return "(" + dart.str(this.first) + " * " + dart.str(this.second) + ")";
    }
  };
  (math_expressions.Times.new = function(first, second) {
    math_expressions.Times.__proto__.new.call(this, first, second);
    ;
  }).prototype = math_expressions.Times.prototype;
  dart.addTypeTests(math_expressions.Times);
  dart.addTypeCaches(math_expressions.Times);
  dart.setMethodSignature(math_expressions.Times, () => ({
    __proto__: dart.getMethods(math_expressions.Times.__proto__),
    derive: dart.fnType(math_expressions.Expression, [core.String]),
    evaluate: dart.fnType(dart.dynamic, [math_expressions.EvaluationType, math_expressions.ContextModel])
  }));
  dart.setLibraryUri(math_expressions.Times, I[1]);
  dart.defineExtensionMethods(math_expressions.Times, ['toString']);
  math_expressions.Divide = class Divide extends math_expressions.BinaryOperator {
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[2], 406, 28, "toVar");
      return this.first.derive(toVar)['*'](this.second)['-'](this.first['*'](this.second.derive(toVar)))['/'](this.second['*'](this.second));
    }
    simplify() {
      let firstOp = this.first.simplify();
      let secondOp = this.second.simplify();
      let tempResult = null;
      let negative = false;
      if (math_expressions.UnaryMinus.is(firstOp)) {
        firstOp = firstOp.exp;
        negative = !negative;
      }
      if (math_expressions.UnaryMinus.is(secondOp)) {
        secondOp = secondOp.exp;
        negative = !negative;
      }
      if (dart.test(this[_isNumber](firstOp, 0))) {
        return firstOp;
      }
      if (dart.test(this[_isNumber](secondOp, 1))) {
        tempResult = firstOp;
      } else {
        tempResult = new math_expressions.Divide.new(firstOp, secondOp);
      }
      return negative ? new math_expressions.UnaryMinus.new(tempResult) : tempResult;
    }
    evaluate(type, context) {
      let t3;
      if (type == null) dart.nullFailed(I[2], 452, 35, "type");
      if (context == null) dart.nullFailed(I[2], 452, 54, "context");
      let firstEval = this.first.evaluate(type, context);
      let secondEval = this.second.evaluate(type, context);
      if (type == math_expressions.EvaluationType.VECTOR) {
        if (typeof secondEval == 'number') {
        } else {
          let $eval = (t3 = dart.dsend(firstEval, 'clone', []), (() => {
            dart.dsend(t3, 'divide', [secondEval]);
            return t3;
          })());
          return $eval;
        }
      }
      return dart.dsend(firstEval, '/', [secondEval]);
    }
    toString() {
      return "(" + dart.str(this.first) + " / " + dart.str(this.second) + ")";
    }
  };
  (math_expressions.Divide.new = function(dividend, divisor) {
    math_expressions.Divide.__proto__.new.call(this, dividend, divisor);
    ;
  }).prototype = math_expressions.Divide.prototype;
  dart.addTypeTests(math_expressions.Divide);
  dart.addTypeCaches(math_expressions.Divide);
  dart.setMethodSignature(math_expressions.Divide, () => ({
    __proto__: dart.getMethods(math_expressions.Divide.__proto__),
    derive: dart.fnType(math_expressions.Expression, [core.String]),
    evaluate: dart.fnType(dart.dynamic, [math_expressions.EvaluationType, math_expressions.ContextModel])
  }));
  dart.setLibraryUri(math_expressions.Divide, I[1]);
  dart.defineExtensionMethods(math_expressions.Divide, ['toString']);
  math_expressions.Modulo = class Modulo extends math_expressions.BinaryOperator {
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[2], 488, 28, "toVar");
      let a2 = new math_expressions.Abs.new(this.second);
      return this.first.derive(toVar)['-'](new math_expressions.Floor.new(this.first['/'](a2))['*'](a2.derive(toVar)));
    }
    simplify() {
      let firstOp = this.first.simplify();
      let secondOp = this.second.simplify();
      if (dart.test(this[_isNumber](firstOp, 0))) {
        return firstOp;
      }
      if (math_expressions.UnaryMinus.is(secondOp)) {
        secondOp = secondOp.exp;
      }
      return new math_expressions.Modulo.new(firstOp, secondOp);
    }
    evaluate(type, context) {
      if (type == null) dart.nullFailed(I[2], 514, 35, "type");
      if (context == null) dart.nullFailed(I[2], 514, 54, "context");
      let firstEval = this.first.evaluate(type, context);
      let secondEval = this.second.evaluate(type, context);
      if (type == math_expressions.EvaluationType.REAL) {
        return dart.dsend(firstEval, '%', [secondEval]);
      }
      dart.throw(new core.UnimplementedError.new("Evaluate Modulo with type " + dart.str(type) + " not supported yet."));
    }
    toString() {
      return "(" + dart.str(this.first) + " % " + dart.str(this.second) + ")";
    }
  };
  (math_expressions.Modulo.new = function(dividend, divisor) {
    math_expressions.Modulo.__proto__.new.call(this, dividend, divisor);
    ;
  }).prototype = math_expressions.Modulo.prototype;
  dart.addTypeTests(math_expressions.Modulo);
  dart.addTypeCaches(math_expressions.Modulo);
  dart.setMethodSignature(math_expressions.Modulo, () => ({
    __proto__: dart.getMethods(math_expressions.Modulo.__proto__),
    derive: dart.fnType(math_expressions.Expression, [core.String]),
    evaluate: dart.fnType(dart.dynamic, [math_expressions.EvaluationType, math_expressions.ContextModel])
  }));
  dart.setLibraryUri(math_expressions.Modulo, I[1]);
  dart.defineExtensionMethods(math_expressions.Modulo, ['toString']);
  math_expressions.Power = class Power extends math_expressions.BinaryOperator {
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[2], 543, 28, "toVar");
      return this.asE().derive(toVar);
    }
    simplify() {
      let baseOp = this.first.simplify();
      let exponentOp = this.second.simplify();
      if (dart.test(this[_isNumber](baseOp, 0))) {
        return baseOp;
      }
      if (dart.test(this[_isNumber](baseOp, 1))) {
        return baseOp;
      }
      if (dart.test(this[_isNumber](exponentOp, 0))) {
        return new math_expressions.Number.new(1.0);
      }
      if (dart.test(this[_isNumber](exponentOp, 1))) {
        return baseOp;
      }
      return new math_expressions.Power.new(baseOp, exponentOp);
    }
    evaluate(type, context) {
      if (type == null) dart.nullFailed(I[2], 591, 35, "type");
      if (context == null) dart.nullFailed(I[2], 591, 54, "context");
      if (type == math_expressions.EvaluationType.REAL) {
        return math.pow(core.num.as(this.first.evaluate(type, context)), core.num.as(this.second.evaluate(type, context)));
      }
      if (type == math_expressions.EvaluationType.INTERVAL) {
        let interval = math_expressions.Interval.as(this.first.evaluate(type, context));
        let exponent = this.second.evaluate(math_expressions.EvaluationType.REAL, context);
        if (typeof exponent == 'number') {
          exponent = exponent[$toInt]();
        }
        let evalMin = null;
        let evalMax = null;
        if (dart.dtest(dart.dload(exponent, 'isOdd'))) {
          evalMin = math.pow(interval.min, core.num.as(exponent));
          evalMax = math.pow(interval.max, core.num.as(exponent));
        } else {
          if (dart.notNull(interval.min) >= 0) {
            evalMin = math.pow(interval.min, core.num.as(exponent));
            evalMax = math.pow(interval.max, core.num.as(exponent));
          }
          if (dart.notNull(interval.min) >= 0) {
            evalMin = math.pow(interval.max, core.num.as(exponent));
            evalMax = math.pow(interval.min, core.num.as(exponent));
          }
          evalMin = 0;
          evalMax = math.max(core.num, math.pow(interval.min, core.num.as(exponent)), math.pow(interval.min, core.num.as(exponent)));
        }
        if (!(dart.notNull(evalMin) <= dart.notNull(evalMax))) dart.assertFailed(null, I[2], 636, 14, "evalMin <= evalMax");
        return new math_expressions.Interval.new(evalMin, evalMax);
      }
      dart.throw(new core.UnimplementedError.new("Evaluate Power with type " + dart.str(type) + " not supported yet."));
    }
    toString() {
      return "(" + dart.str(this.first) + "^" + dart.str(this.second) + ")";
    }
    asE() {
      return new math_expressions.Exponential.new(this.second['*'](new math_expressions.Ln.new(this.first)));
    }
  };
  (math_expressions.Power.new = function(x, exp) {
    math_expressions.Power.__proto__.new.call(this, x, exp);
    ;
  }).prototype = math_expressions.Power.prototype;
  dart.addTypeTests(math_expressions.Power);
  dart.addTypeCaches(math_expressions.Power);
  dart.setMethodSignature(math_expressions.Power, () => ({
    __proto__: dart.getMethods(math_expressions.Power.__proto__),
    derive: dart.fnType(math_expressions.Expression, [core.String]),
    evaluate: dart.fnType(dart.dynamic, [math_expressions.EvaluationType, math_expressions.ContextModel]),
    asE: dart.fnType(math_expressions.Expression, [])
  }));
  dart.setLibraryUri(math_expressions.Power, I[1]);
  dart.defineExtensionMethods(math_expressions.Power, ['toString']);
  var value$ = dart.privateName(math_expressions, "Literal.value");
  math_expressions.Literal = class Literal extends math_expressions.Expression {
    get value() {
      return this[value$];
    }
    set value(value) {
      this[value$] = value;
    }
    isConstant() {
      return false;
    }
    getConstantValue() {
      dart.throw(new core.StateError.new("Literal " + dart.str(this) + " is not constant."));
    }
    toString() {
      return dart.toString(this.value);
    }
  };
  (math_expressions.Literal.new = function(value = null) {
    this[value$] = value;
    ;
  }).prototype = math_expressions.Literal.prototype;
  dart.addTypeTests(math_expressions.Literal);
  dart.addTypeCaches(math_expressions.Literal);
  dart.setMethodSignature(math_expressions.Literal, () => ({
    __proto__: dart.getMethods(math_expressions.Literal.__proto__),
    isConstant: dart.fnType(core.bool, []),
    getConstantValue: dart.fnType(dart.dynamic, [])
  }));
  dart.setLibraryUri(math_expressions.Literal, I[1]);
  dart.setFieldSignature(math_expressions.Literal, () => ({
    __proto__: dart.getFields(math_expressions.Literal.__proto__),
    value: dart.fieldType(dart.dynamic)
  }));
  dart.defineExtensionMethods(math_expressions.Literal, ['toString']);
  math_expressions.Number = class Number extends math_expressions.Literal {
    isConstant() {
      return true;
    }
    getConstantValue() {
      return core.double.as(this.value);
    }
    evaluate(type, context) {
      if (type == null) dart.nullFailed(I[2], 690, 35, "type");
      if (context == null) dart.nullFailed(I[2], 690, 54, "context");
      if (type == math_expressions.EvaluationType.REAL) {
        return this.value;
      }
      if (type == math_expressions.EvaluationType.INTERVAL) {
        let intLit = new math_expressions.IntervalLiteral.fromSingle(this);
        return intLit.evaluate(type, context);
      }
      if (type == math_expressions.EvaluationType.VECTOR) {
        return this.value;
      }
      dart.throw(new core.UnsupportedError.new("Number " + dart.str(this) + " can not be interpreted as: " + dart.str(type)));
    }
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[2], 710, 28, "toVar");
      return new math_expressions.Number.new(0.0);
    }
  };
  (math_expressions.Number.new = function(value) {
    if (value == null) dart.nullFailed(I[2], 681, 14, "value");
    math_expressions.Number.__proto__.new.call(this, value[$toDouble]());
    ;
  }).prototype = math_expressions.Number.prototype;
  dart.addTypeTests(math_expressions.Number);
  dart.addTypeCaches(math_expressions.Number);
  dart.setMethodSignature(math_expressions.Number, () => ({
    __proto__: dart.getMethods(math_expressions.Number.__proto__),
    getConstantValue: dart.fnType(core.double, []),
    evaluate: dart.fnType(dart.dynamic, [math_expressions.EvaluationType, math_expressions.ContextModel]),
    derive: dart.fnType(math_expressions.Expression, [core.String])
  }));
  dart.setLibraryUri(math_expressions.Number, I[1]);
  math_expressions.Vector = class Vector extends math_expressions.Literal {
    _get(i) {
      if (i == null) dart.nullFailed(I[2], 724, 30, "i");
      return this.elements[$_get](i);
    }
    get elements() {
      return T.ListOfExpression().as(this.value);
    }
    get length() {
      return this.elements[$length];
    }
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[2], 733, 28, "toVar");
      let elementDerivative = this.elements[$map](math_expressions.Expression, dart.fn(item => {
        if (item == null) dart.nullFailed(I[2], 735, 23, "item");
        return item.derive(toVar);
      }, T.ExpressionToExpression()))[$toList]();
      return new math_expressions.Vector.new(elementDerivative);
    }
    simplify() {
      let simplifiedElements = this.elements[$map](math_expressions.Expression, dart.fn(item => {
        if (item == null) dart.nullFailed(I[2], 743, 46, "item");
        return item.simplify();
      }, T.ExpressionToExpression()))[$toList]();
      return new math_expressions.Vector.new(simplifiedElements);
    }
    evaluate(type, context) {
      if (type == null) dart.nullFailed(I[2], 749, 35, "type");
      if (context == null) dart.nullFailed(I[2], 749, 54, "context");
      if (type == math_expressions.EvaluationType.VECTOR) {
        let elementType = math_expressions.EvaluationType.REAL;
        if (this.length === 1) {
          return this.elements[$_get](0).evaluate(elementType, context);
        }
        if (this.length === 2) {
          let x = null;
          let y = null;
          x = core.double.as(this.elements[$_get](0).evaluate(elementType, context));
          y = core.double.as(this.elements[$_get](1).evaluate(elementType, context));
          return vector_math.Vector2.new(x, y);
        }
        if (this.length === 3) {
          let x = null;
          let y = null;
          let z = null;
          x = core.double.as(this.elements[$_get](0).evaluate(elementType, context));
          y = core.double.as(this.elements[$_get](1).evaluate(elementType, context));
          z = core.double.as(this.elements[$_get](2).evaluate(elementType, context));
          return vector_math.Vector3.new(x, y, z);
        }
        if (this.length === 4) {
          let x = null;
          let y = null;
          let z = null;
          let w = null;
          x = core.double.as(this.elements[$_get](0).evaluate(elementType, context));
          y = core.double.as(this.elements[$_get](1).evaluate(elementType, context));
          z = core.double.as(this.elements[$_get](2).evaluate(elementType, context));
          w = core.double.as(this.elements[$_get](3).evaluate(elementType, context));
          return vector_math.Vector4.new(x, y, z, w);
        }
        if (dart.notNull(this.length) > 4) {
          dart.throw(new core.UnimplementedError.new("Vector of arbitrary length (> 4) are not supported yet."));
        }
      }
      if (type == math_expressions.EvaluationType.REAL && this.length === 1) {
        return this.elements[$_get](0).evaluate(type, context);
      }
      dart.throw(new core.UnsupportedError.new("Vector " + dart.str(this) + " with length " + dart.str(this.length) + " can not be interpreted as: " + dart.str(type)));
    }
    isConstant() {
      return this.elements[$fold](core.bool, true, dart.fn((prev, elem) => {
        if (prev == null) dart.nullFailed(I[2], 801, 14, "prev");
        if (elem == null) dart.nullFailed(I[2], 801, 20, "elem");
        return dart.test(prev) && math_expressions.Literal.is(elem) && dart.test(elem.isConstant());
      }, T.boolAndExpressionTobool()));
    }
    getConstantValue() {
      let constVals = this.elements[$map](math_expressions.Expression, dart.fn(e => {
        if (e == null) dart.nullFailed(I[2], 806, 49, "e");
        return math_expressions.Expression.as(math_expressions.Literal.is(e) ? e.getConstantValue() : dart.throw(new core.UnsupportedError.new("Vector " + dart.str(this) + " is not constant.")));
      }, T.ExpressionToExpression()));
      return new math_expressions.Vector.new(T.ListOfExpression().as(constVals));
    }
  };
  (math_expressions.Vector.new = function(elements) {
    if (elements == null) dart.nullFailed(I[2], 721, 27, "elements");
    math_expressions.Vector.__proto__.new.call(this, elements);
    ;
  }).prototype = math_expressions.Vector.prototype;
  dart.addTypeTests(math_expressions.Vector);
  dart.addTypeCaches(math_expressions.Vector);
  dart.setMethodSignature(math_expressions.Vector, () => ({
    __proto__: dart.getMethods(math_expressions.Vector.__proto__),
    _get: dart.fnType(math_expressions.Expression, [core.int]),
    derive: dart.fnType(math_expressions.Expression, [core.String]),
    evaluate: dart.fnType(dart.dynamic, [math_expressions.EvaluationType, math_expressions.ContextModel]),
    getConstantValue: dart.fnType(math_expressions.Vector, [])
  }));
  dart.setGetterSignature(math_expressions.Vector, () => ({
    __proto__: dart.getGetters(math_expressions.Vector.__proto__),
    elements: core.List$(math_expressions.Expression),
    length: core.int
  }));
  dart.setLibraryUri(math_expressions.Vector, I[1]);
  var name$ = dart.privateName(math_expressions, "Variable.name");
  math_expressions.Variable = class Variable extends math_expressions.Literal {
    get name() {
      return this[name$];
    }
    set name(value) {
      this[name$] = value;
    }
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[2], 823, 28, "toVar");
      return this.name == toVar ? new math_expressions.Number.new(1.0) : new math_expressions.Number.new(0.0);
    }
    toString() {
      return dart.str(this.name);
    }
    evaluate(type, context) {
      if (type == null) dart.nullFailed(I[2], 829, 35, "type");
      if (context == null) dart.nullFailed(I[2], 829, 54, "context");
      return context.getExpression(this.name).evaluate(type, context);
    }
  };
  (math_expressions.Variable.new = function(name) {
    if (name == null) dart.nullFailed(I[2], 820, 17, "name");
    this[name$] = name;
    math_expressions.Variable.__proto__.new.call(this);
    ;
  }).prototype = math_expressions.Variable.prototype;
  dart.addTypeTests(math_expressions.Variable);
  dart.addTypeCaches(math_expressions.Variable);
  dart.setMethodSignature(math_expressions.Variable, () => ({
    __proto__: dart.getMethods(math_expressions.Variable.__proto__),
    derive: dart.fnType(math_expressions.Expression, [core.String]),
    evaluate: dart.fnType(dart.dynamic, [math_expressions.EvaluationType, math_expressions.ContextModel])
  }));
  dart.setLibraryUri(math_expressions.Variable, I[1]);
  dart.setFieldSignature(math_expressions.Variable, () => ({
    __proto__: dart.getFields(math_expressions.Variable.__proto__),
    name: dart.fieldType(core.String)
  }));
  dart.defineExtensionMethods(math_expressions.Variable, ['toString']);
  math_expressions.BoundVariable = class BoundVariable extends math_expressions.Variable {
    isConstant() {
      return core.bool.as(math_expressions.Literal.is(this.value) ? dart.dsend(this.value, 'isConstant', []) : false);
    }
    getConstantValue() {
      return dart.dload(this.value, 'value');
    }
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[2], 853, 28, "toVar");
      return math_expressions.Expression.as(dart.dsend(this.value, 'derive', [toVar]));
    }
    simplify() {
      return math_expressions.Expression.as(dart.dsend(this.value, 'simplify', []));
    }
    evaluate(type, context) {
      if (type == null) dart.nullFailed(I[2], 861, 35, "type");
      if (context == null) dart.nullFailed(I[2], 861, 54, "context");
      return dart.dsend(this.value, 'evaluate', [type, context]);
    }
    toString() {
      return "{" + dart.str(this.value) + "}";
    }
  };
  (math_expressions.BoundVariable.new = function(expr) {
    if (expr == null) dart.nullFailed(I[2], 840, 28, "expr");
    math_expressions.BoundVariable.__proto__.new.call(this, "anon");
    this.value = expr;
  }).prototype = math_expressions.BoundVariable.prototype;
  dart.addTypeTests(math_expressions.BoundVariable);
  dart.addTypeCaches(math_expressions.BoundVariable);
  dart.setLibraryUri(math_expressions.BoundVariable, I[1]);
  dart.defineExtensionMethods(math_expressions.BoundVariable, ['toString']);
  var min$0 = dart.privateName(math_expressions, "IntervalLiteral.min");
  var max$0 = dart.privateName(math_expressions, "IntervalLiteral.max");
  math_expressions.IntervalLiteral = class IntervalLiteral extends math_expressions.Literal {
    get min() {
      return this[min$0];
    }
    set min(value) {
      this[min$0] = value;
    }
    get max() {
      return this[max$0];
    }
    set max(value) {
      this[max$0] = value;
    }
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[2], 883, 28, "toVar");
      dart.throw(new core.UnimplementedError.new("Interval differentiation not supported yet."));
    }
    simplify() {
      return new math_expressions.IntervalLiteral.new(this.min.simplify(), this.max.simplify());
    }
    evaluate(type, context) {
      if (type == null) dart.nullFailed(I[2], 893, 35, "type");
      if (context == null) dart.nullFailed(I[2], 893, 54, "context");
      let minEval = core.num.as(this.min.evaluate(math_expressions.EvaluationType.REAL, context));
      let maxEval = core.num.as(this.max.evaluate(math_expressions.EvaluationType.REAL, context));
      if (type == math_expressions.EvaluationType.INTERVAL) {
        return new math_expressions.Interval.new(minEval, maxEval);
      }
      if (type == math_expressions.EvaluationType.REAL) {
        if (minEval == maxEval) {
          return minEval;
        }
      }
      dart.throw(new core.UnsupportedError.new("Interval " + dart.str(this) + " can not be interpreted as: " + dart.str(type)));
    }
    toString() {
      return "I[" + dart.str(this.min) + ", " + dart.str(this.max) + "]";
    }
    isConstant() {
      return math_expressions.Literal.is(this.min) && dart.test(math_expressions.Literal.as(this.min).isConstant()) && math_expressions.Literal.is(this.max) && dart.test(math_expressions.Literal.as(this.max).isConstant());
    }
    getConstantValue() {
      return new math_expressions.Interval.new(core.num.as(math_expressions.Literal.as(this.min).getConstantValue()), core.num.as(math_expressions.Literal.as(this.max).getConstantValue()));
    }
  };
  (math_expressions.IntervalLiteral.new = function(min, max) {
    if (min == null) dart.nullFailed(I[2], 875, 24, "min");
    if (max == null) dart.nullFailed(I[2], 875, 34, "max");
    this[min$0] = min;
    this[max$0] = max;
    math_expressions.IntervalLiteral.__proto__.new.call(this);
    ;
  }).prototype = math_expressions.IntervalLiteral.prototype;
  (math_expressions.IntervalLiteral.fromSingle = function(exp) {
    if (exp == null) dart.nullFailed(I[2], 878, 41, "exp");
    this[min$0] = exp;
    this[max$0] = exp;
    math_expressions.IntervalLiteral.__proto__.new.call(this);
    ;
  }).prototype = math_expressions.IntervalLiteral.prototype;
  dart.addTypeTests(math_expressions.IntervalLiteral);
  dart.addTypeCaches(math_expressions.IntervalLiteral);
  dart.setMethodSignature(math_expressions.IntervalLiteral, () => ({
    __proto__: dart.getMethods(math_expressions.IntervalLiteral.__proto__),
    derive: dart.fnType(math_expressions.Expression, [core.String]),
    evaluate: dart.fnType(dart.dynamic, [math_expressions.EvaluationType, math_expressions.ContextModel]),
    getConstantValue: dart.fnType(math_expressions.Interval, [])
  }));
  dart.setLibraryUri(math_expressions.IntervalLiteral, I[1]);
  dart.setFieldSignature(math_expressions.IntervalLiteral, () => ({
    __proto__: dart.getFields(math_expressions.IntervalLiteral.__proto__),
    min: dart.fieldType(math_expressions.Expression),
    max: dart.fieldType(math_expressions.Expression)
  }));
  dart.defineExtensionMethods(math_expressions.IntervalLiteral, ['toString']);
  var name$0 = dart.privateName(math_expressions, "MathFunction.name");
  var args$ = dart.privateName(math_expressions, "MathFunction.args");
  math_expressions.MathFunction = class MathFunction extends math_expressions.Expression {
    get name() {
      return this[name$0];
    }
    set name(value) {
      this[name$0] = value;
    }
    get args() {
      return this[args$];
    }
    set args(value) {
      this[args$] = value;
    }
    ['&'](g) {
      if (g == null) dart.nullFailed(I[3], 24, 40, "g");
      return new math_expressions.CompositeFunction.new(this, g);
    }
    getParam(i) {
      if (i == null) dart.nullFailed(I[3], 27, 25, "i");
      return this.args[$_get](i);
    }
    getParamByName(name) {
      if (name == null) dart.nullFailed(I[3], 30, 34, "name");
      return this.args[$singleWhere](dart.fn(e => {
        if (e == null) dart.nullFailed(I[3], 31, 25, "e");
        return e.name == name;
      }, T.VariableTobool()));
    }
    get domainDimension() {
      return this.args[$length];
    }
    toString() {
      return dart.str(this.name) + "(" + dart.str(this.args) + ")";
    }
    toFullString() {
      return this.toString();
    }
  };
  (math_expressions.MathFunction.new = function(name, args) {
    if (name == null) dart.nullFailed(I[3], 14, 21, "name");
    if (args == null) dart.nullFailed(I[3], 14, 32, "args");
    this[name$0] = name;
    this[args$] = args;
    ;
  }).prototype = math_expressions.MathFunction.prototype;
  (math_expressions.MathFunction._empty = function(name) {
    if (name == null) dart.nullFailed(I[3], 21, 28, "name");
    this[name$0] = name;
    this[args$] = T.JSArrayOfVariable().of([]);
    ;
  }).prototype = math_expressions.MathFunction.prototype;
  dart.addTypeTests(math_expressions.MathFunction);
  dart.addTypeCaches(math_expressions.MathFunction);
  dart.setMethodSignature(math_expressions.MathFunction, () => ({
    __proto__: dart.getMethods(math_expressions.MathFunction.__proto__),
    '&': dart.fnType(math_expressions.MathFunction, [math_expressions.MathFunction]),
    getParam: dart.fnType(math_expressions.Variable, [core.int]),
    getParamByName: dart.fnType(math_expressions.Variable, [core.String]),
    toFullString: dart.fnType(core.String, [])
  }));
  dart.setGetterSignature(math_expressions.MathFunction, () => ({
    __proto__: dart.getGetters(math_expressions.MathFunction.__proto__),
    domainDimension: core.int
  }));
  dart.setLibraryUri(math_expressions.MathFunction, I[1]);
  dart.setFieldSignature(math_expressions.MathFunction, () => ({
    __proto__: dart.getFields(math_expressions.MathFunction.__proto__),
    name: dart.fieldType(core.String),
    args: dart.fieldType(core.List$(math_expressions.Variable))
  }));
  dart.defineExtensionMethods(math_expressions.MathFunction, ['toString']);
  var f$ = dart.privateName(math_expressions, "CompositeFunction.f");
  var g$ = dart.privateName(math_expressions, "CompositeFunction.g");
  math_expressions.CompositeFunction = class CompositeFunction extends math_expressions.MathFunction {
    get f() {
      return this[f$];
    }
    set f(value) {
      this[f$] = value;
    }
    get g() {
      return this[g$];
    }
    set g(value) {
      this[g$] = value;
    }
    get gDomainDimension() {
      return this.g.domainDimension;
    }
    get domainDimension() {
      return this.f.domainDimension;
    }
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[3], 92, 28, "toVar");
      let gDF = null;
      let gD = this.g.derive(toVar);
      if (!math_expressions.MathFunction.is(gD)) {
        gDF = new math_expressions.CustomFunction.new("d" + dart.str(this.g.name), this.g.args, gD);
      } else {
        gDF = gD;
      }
      return new math_expressions.CompositeFunction.new(this.f, gDF)['*'](this.f.derive(toVar));
    }
    simplify() {
      let fSimpl = math_expressions.MathFunction.as(this.f.simplify());
      let gSimpl = math_expressions.MathFunction.as(this.g.simplify());
      return new math_expressions.CompositeFunction.new(fSimpl, gSimpl);
    }
    evaluate(type, context) {
      let t3, t3$, t3$0;
      if (type == null) dart.nullFailed(I[3], 127, 35, "type");
      if (context == null) dart.nullFailed(I[3], 127, 54, "context");
      let fEval = null;
      let childScope = context.createChildScope();
      if (this.gDomainDimension === 1) {
        fEval = this.f.evaluate(math_expressions.EvaluationType.REAL, context);
        childScope.bindVariable(this.g.getParam(0), this[_toExpression](fEval));
        return this.g.evaluate(type, childScope);
      }
      if (this.gDomainDimension === 2) {
        fEval = this.f.evaluate(math_expressions.EvaluationType.VECTOR, context);
        t3 = childScope;
        (() => {
          t3.bindVariable(this.g.getParam(0), this[_toExpression](dart.dload(fEval, 'x')));
          t3.bindVariable(this.g.getParam(1), this[_toExpression](dart.dload(fEval, 'y')));
          return t3;
        })();
        return this.g.evaluate(type, childScope);
      }
      if (this.gDomainDimension === 3) {
        fEval = this.f.evaluate(math_expressions.EvaluationType.VECTOR, context);
        t3$ = childScope;
        (() => {
          t3$.bindVariable(this.g.getParam(0), this[_toExpression](dart.dload(fEval, 'x')));
          t3$.bindVariable(this.g.getParam(1), this[_toExpression](dart.dload(fEval, 'y')));
          t3$.bindVariable(this.g.getParam(2), this[_toExpression](dart.dload(fEval, 'z')));
          return t3$;
        })();
        return this.g.evaluate(type, childScope);
      }
      if (this.gDomainDimension === 4) {
        fEval = this.f.evaluate(math_expressions.EvaluationType.VECTOR, context);
        t3$0 = childScope;
        (() => {
          t3$0.bindVariable(this.g.getParam(0), this[_toExpression](dart.dload(fEval, 'x')));
          t3$0.bindVariable(this.g.getParam(1), this[_toExpression](dart.dload(fEval, 'y')));
          t3$0.bindVariable(this.g.getParam(2), this[_toExpression](dart.dload(fEval, 'z')));
          t3$0.bindVariable(this.g.getParam(3), this[_toExpression](dart.dload(fEval, 'w')));
          return t3$0;
        })();
        return this.g.evaluate(type, childScope);
      }
      dart.throw(new core.UnimplementedError.new("Vectors > 4 not supported yet."));
    }
  };
  (math_expressions.CompositeFunction.new = function(f, g) {
    if (f == null) dart.nullFailed(I[3], 80, 26, "f");
    if (g == null) dart.nullFailed(I[3], 80, 34, "g");
    this[f$] = f;
    this[g$] = g;
    math_expressions.CompositeFunction.__proto__.new.call(this, "comp(" + dart.str(f.name) + "," + dart.str(g.name) + ")", f.args);
    ;
  }).prototype = math_expressions.CompositeFunction.prototype;
  dart.addTypeTests(math_expressions.CompositeFunction);
  dart.addTypeCaches(math_expressions.CompositeFunction);
  dart.setMethodSignature(math_expressions.CompositeFunction, () => ({
    __proto__: dart.getMethods(math_expressions.CompositeFunction.__proto__),
    derive: dart.fnType(math_expressions.Expression, [core.String]),
    evaluate: dart.fnType(dart.dynamic, [math_expressions.EvaluationType, math_expressions.ContextModel])
  }));
  dart.setGetterSignature(math_expressions.CompositeFunction, () => ({
    __proto__: dart.getGetters(math_expressions.CompositeFunction.__proto__),
    gDomainDimension: core.int
  }));
  dart.setLibraryUri(math_expressions.CompositeFunction, I[1]);
  dart.setFieldSignature(math_expressions.CompositeFunction, () => ({
    __proto__: dart.getFields(math_expressions.CompositeFunction.__proto__),
    f: dart.fieldType(math_expressions.MathFunction),
    g: dart.fieldType(math_expressions.MathFunction)
  }));
  var expression$ = dart.privateName(math_expressions, "CustomFunction.expression");
  math_expressions.CustomFunction = class CustomFunction extends math_expressions.MathFunction {
    get expression() {
      return this[expression$];
    }
    set expression(value) {
      this[expression$] = value;
    }
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[3], 202, 28, "toVar");
      return new math_expressions.CustomFunction.new(this.name, this.args, this.expression.derive(toVar));
    }
    simplify() {
      return new math_expressions.CustomFunction.new(this.name, this.args, this.expression.simplify());
    }
    evaluate(type, context) {
      if (type == null) dart.nullFailed(I[3], 212, 35, "type");
      if (context == null) dart.nullFailed(I[3], 212, 54, "context");
      return this.expression.evaluate(type, context);
    }
    toFullString() {
      return dart.str(this.name) + "(" + dart.str(this.args) + ") = " + dart.str(this.expression);
    }
  };
  (math_expressions.CustomFunction.new = function(name, args, expression) {
    if (name == null) dart.nullFailed(I[3], 198, 25, "name");
    if (args == null) dart.nullFailed(I[3], 198, 46, "args");
    if (expression == null) dart.nullFailed(I[3], 198, 57, "expression");
    this[expression$] = expression;
    math_expressions.CustomFunction.__proto__.new.call(this, name, args);
    ;
  }).prototype = math_expressions.CustomFunction.prototype;
  dart.addTypeTests(math_expressions.CustomFunction);
  dart.addTypeCaches(math_expressions.CustomFunction);
  dart.setMethodSignature(math_expressions.CustomFunction, () => ({
    __proto__: dart.getMethods(math_expressions.CustomFunction.__proto__),
    derive: dart.fnType(math_expressions.Expression, [core.String]),
    evaluate: dart.fnType(dart.dynamic, [math_expressions.EvaluationType, math_expressions.ContextModel])
  }));
  dart.setLibraryUri(math_expressions.CustomFunction, I[1]);
  dart.setFieldSignature(math_expressions.CustomFunction, () => ({
    __proto__: dart.getFields(math_expressions.CustomFunction.__proto__),
    expression: dart.fieldType(math_expressions.Expression)
  }));
  var _wrapIntoVariable = dart.privateName(math_expressions, "_wrapIntoVariable");
  math_expressions.DefaultFunction = class DefaultFunction extends math_expressions.MathFunction {
    [_wrapIntoVariable](e) {
      if (e == null) dart.nullFailed(I[3], 259, 41, "e");
      if (math_expressions.Variable.is(e)) {
        return e;
      } else {
        return new math_expressions.BoundVariable.new(e);
      }
    }
    toString() {
      return dart.str(this.name) + "(" + dart.str(this.args[$join](",")) + ")";
    }
  };
  (math_expressions.DefaultFunction._unary = function(name, arg) {
    if (name == null) dart.nullFailed(I[3], 238, 33, "name");
    if (arg == null) dart.nullFailed(I[3], 238, 50, "arg");
    math_expressions.DefaultFunction.__proto__._empty.call(this, name);
    let bindingVariable = this[_wrapIntoVariable](arg);
    this.args = T.JSArrayOfVariable().of([bindingVariable]);
  }).prototype = math_expressions.DefaultFunction.prototype;
  (math_expressions.DefaultFunction._binary = function(name, arg1, arg2) {
    if (name == null) dart.nullFailed(I[3], 250, 34, "name");
    if (arg1 == null) dart.nullFailed(I[3], 250, 51, "arg1");
    if (arg2 == null) dart.nullFailed(I[3], 250, 68, "arg2");
    math_expressions.DefaultFunction.__proto__._empty.call(this, name);
    let bindingVariable1 = this[_wrapIntoVariable](arg1);
    let bindingVariable2 = this[_wrapIntoVariable](arg2);
    this.args = T.JSArrayOfVariable().of([bindingVariable1, bindingVariable2]);
  }).prototype = math_expressions.DefaultFunction.prototype;
  dart.addTypeTests(math_expressions.DefaultFunction);
  dart.addTypeCaches(math_expressions.DefaultFunction);
  dart.setMethodSignature(math_expressions.DefaultFunction, () => ({
    __proto__: dart.getMethods(math_expressions.DefaultFunction.__proto__),
    [_wrapIntoVariable]: dart.fnType(math_expressions.Variable, [math_expressions.Expression])
  }));
  dart.setLibraryUri(math_expressions.DefaultFunction, I[1]);
  dart.defineExtensionMethods(math_expressions.DefaultFunction, ['toString']);
  math_expressions.Exponential = class Exponential extends math_expressions.DefaultFunction {
    get exp() {
      return this.getParam(0);
    }
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[3], 293, 28, "toVar");
      return new math_expressions.Times.new(this, this.exp.derive(toVar));
    }
    simplify() {
      let expSimpl = this.exp.simplify();
      if (dart.test(this[_isNumber](expSimpl, 0))) {
        return new math_expressions.Number.new(1);
      }
      if (dart.test(this[_isNumber](expSimpl, 1))) {
        return new math_expressions.Number.new(2.718281828459045);
      }
      if (math_expressions.Times.is(expSimpl) && math_expressions.Ln.is(expSimpl.second)) {
        let ln = math_expressions.Ln.as(expSimpl.second);
        return new math_expressions.Power.new(ln.arg, expSimpl.first);
      }
      return new math_expressions.Exponential.new(expSimpl);
    }
    evaluate(type, context) {
      if (type == null) dart.nullFailed(I[3], 321, 35, "type");
      if (context == null) dart.nullFailed(I[3], 321, 54, "context");
      let expEval = this.exp.evaluate(type, context);
      if (type == math_expressions.EvaluationType.REAL) {
        return math.exp(core.num.as(expEval));
      }
      if (type == math_expressions.EvaluationType.INTERVAL) {
        return new math_expressions.Interval.new(math.exp(core.num.as(dart.dload(expEval, 'min'))), math.exp(core.num.as(dart.dload(expEval, 'max'))));
      }
      dart.throw(new core.UnimplementedError.new("Can not evaluate " + dart.str(this.name) + " on " + dart.str(type) + " yet."));
    }
  };
  (math_expressions.Exponential.new = function(exp) {
    if (exp == null) dart.nullFailed(I[3], 287, 26, "exp");
    math_expressions.Exponential.__proto__._unary.call(this, "e", exp);
    ;
  }).prototype = math_expressions.Exponential.prototype;
  dart.addTypeTests(math_expressions.Exponential);
  dart.addTypeCaches(math_expressions.Exponential);
  dart.setMethodSignature(math_expressions.Exponential, () => ({
    __proto__: dart.getMethods(math_expressions.Exponential.__proto__),
    derive: dart.fnType(math_expressions.Expression, [core.String]),
    evaluate: dart.fnType(dart.dynamic, [math_expressions.EvaluationType, math_expressions.ContextModel])
  }));
  dart.setGetterSignature(math_expressions.Exponential, () => ({
    __proto__: dart.getGetters(math_expressions.Exponential.__proto__),
    exp: math_expressions.Expression
  }));
  dart.setLibraryUri(math_expressions.Exponential, I[1]);
  math_expressions.Log = class Log extends math_expressions.DefaultFunction {
    get base() {
      return this.getParam(0);
    }
    get arg() {
      return this.getParam(1);
    }
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[3], 363, 28, "toVar");
      return this.asNaturalLogarithm().derive(toVar);
    }
    simplify() {
      return new math_expressions.Log.new(this.base.simplify(), this.arg.simplify());
    }
    evaluate(type, context) {
      if (type == null) dart.nullFailed(I[3], 370, 35, "type");
      if (context == null) dart.nullFailed(I[3], 370, 54, "context");
      if (type == math_expressions.EvaluationType.REAL) {
        return this.asNaturalLogarithm().evaluate(type, context);
      }
      if (type == math_expressions.EvaluationType.INTERVAL) {
        return this.asNaturalLogarithm().evaluate(type, context);
      }
      dart.throw(new core.UnimplementedError.new("Can not evaluate " + dart.str(this.name) + " on " + dart.str(type) + " yet."));
    }
    asNaturalLogarithm() {
      return new math_expressions.Ln.new(this.arg)['/'](new math_expressions.Ln.new(this.base));
    }
  };
  (math_expressions.Log.new = function(base, arg) {
    if (base == null) dart.nullFailed(I[3], 350, 18, "base");
    if (arg == null) dart.nullFailed(I[3], 350, 35, "arg");
    math_expressions.Log.__proto__._binary.call(this, "log", base, arg);
    ;
  }).prototype = math_expressions.Log.prototype;
  (math_expressions.Log._ln = function(arg) {
    if (arg == null) dart.nullFailed(I[3], 354, 22, "arg");
    math_expressions.Log.__proto__._binary.call(this, "ln", new math_expressions.Number.new(2.718281828459045), arg);
    ;
  }).prototype = math_expressions.Log.prototype;
  dart.addTypeTests(math_expressions.Log);
  dart.addTypeCaches(math_expressions.Log);
  dart.setMethodSignature(math_expressions.Log, () => ({
    __proto__: dart.getMethods(math_expressions.Log.__proto__),
    derive: dart.fnType(math_expressions.Expression, [core.String]),
    evaluate: dart.fnType(dart.dynamic, [math_expressions.EvaluationType, math_expressions.ContextModel]),
    asNaturalLogarithm: dart.fnType(math_expressions.Expression, [])
  }));
  dart.setGetterSignature(math_expressions.Log, () => ({
    __proto__: dart.getGetters(math_expressions.Log.__proto__),
    base: math_expressions.Expression,
    arg: math_expressions.Expression
  }));
  dart.setLibraryUri(math_expressions.Log, I[1]);
  math_expressions.Ln = class Ln extends math_expressions.Log {
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[3], 405, 28, "toVar");
      return this.arg.derive(toVar)['/'](this.arg);
    }
    simplify() {
      let argSimpl = this.arg.simplify();
      if (dart.test(this[_isNumber](argSimpl, 1))) {
        return new math_expressions.Number.new(0);
      }
      return new math_expressions.Ln.new(argSimpl);
    }
    evaluate(type, context) {
      if (type == null) dart.nullFailed(I[3], 422, 35, "type");
      if (context == null) dart.nullFailed(I[3], 422, 54, "context");
      let argEval = this.arg.evaluate(type, context);
      if (type == math_expressions.EvaluationType.REAL) {
        return math.log(core.num.as(argEval));
      }
      if (type == math_expressions.EvaluationType.INTERVAL) {
        return new math_expressions.Interval.new(math.log(core.num.as(dart.dload(argEval, 'min'))), math.log(core.num.as(dart.dload(argEval, 'max'))));
      }
      dart.throw(new core.UnimplementedError.new("Can not evaluate " + dart.str(this.name) + " on " + dart.str(type) + " yet."));
    }
    toString() {
      return "ln(" + dart.str(this.arg) + ")";
    }
  };
  (math_expressions.Ln.new = function(arg) {
    if (arg == null) dart.nullFailed(I[3], 402, 17, "arg");
    math_expressions.Ln.__proto__._ln.call(this, arg);
    ;
  }).prototype = math_expressions.Ln.prototype;
  dart.addTypeTests(math_expressions.Ln);
  dart.addTypeCaches(math_expressions.Ln);
  dart.setLibraryUri(math_expressions.Ln, I[1]);
  dart.defineExtensionMethods(math_expressions.Ln, ['toString']);
  var __Root_n = dart.privateName(math_expressions, "_#Root#n");
  var __Root_n_isSet = dart.privateName(math_expressions, "_#Root#n#isSet");
  math_expressions.Root = class Root extends math_expressions.DefaultFunction {
    get n() {
      let t3;
      return dart.test(this[__Root_n_isSet]) ? (t3 = this[__Root_n], t3) : dart.throw(new _internal.LateError.fieldNI("n"));
    }
    set n(t3) {
      if (t3 == null) dart.nullFailed(I[3], 445, 18, "null");
      if (dart.test(this[__Root_n_isSet]))
        dart.throw(new _internal.LateError.fieldAI("n"));
      else {
        this[__Root_n_isSet] = true;
        this[__Root_n] = t3;
      }
    }
    get arg() {
      return this.getParam(0);
    }
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[3], 474, 28, "toVar");
      return this.asPower().derive(toVar);
    }
    simplify() {
      return new math_expressions.Root.new(this.n, this.arg.simplify());
    }
    evaluate(type, context) {
      if (type == null) dart.nullFailed(I[3], 481, 35, "type");
      if (context == null) dart.nullFailed(I[3], 481, 54, "context");
      return this.asPower().evaluate(type, context);
    }
    toString() {
      return "nrt(" + dart.str(this.n) + "," + dart.str(this.arg) + ")";
    }
    asPower() {
      return new math_expressions.Power.new(this.arg, new math_expressions.Divide.new(new math_expressions.Number.new(1), new math_expressions.Number.new(this.n)));
    }
  };
  (math_expressions.Root.new = function(n, arg) {
    if (n == null) dart.nullFailed(I[3], 452, 13, "n");
    if (arg == null) dart.nullFailed(I[3], 452, 27, "arg");
    this[__Root_n] = null;
    this[__Root_n_isSet] = false;
    this[__Root_n_isSet] = true;
    this[__Root_n] = n;
    math_expressions.Root.__proto__._unary.call(this, "nrt", arg);
    ;
  }).prototype = math_expressions.Root.prototype;
  (math_expressions.Root.fromExpr = function(n, arg) {
    if (n == null) dart.nullFailed(I[3], 455, 24, "n");
    if (arg == null) dart.nullFailed(I[3], 455, 38, "arg");
    this[__Root_n] = null;
    this[__Root_n_isSet] = false;
    math_expressions.Root.__proto__._unary.call(this, "nrt", arg);
    this.n = n.getConstantValue()[$toInt]();
  }).prototype = math_expressions.Root.prototype;
  (math_expressions.Root.sqrt = function(arg) {
    if (arg == null) dart.nullFailed(I[3], 467, 24, "arg");
    this[__Root_n] = null;
    this[__Root_n_isSet] = false;
    this[__Root_n_isSet] = true;
    this[__Root_n] = 2;
    math_expressions.Root.__proto__._unary.call(this, "sqrt", arg);
    ;
  }).prototype = math_expressions.Root.prototype;
  dart.addTypeTests(math_expressions.Root);
  dart.addTypeCaches(math_expressions.Root);
  dart.setMethodSignature(math_expressions.Root, () => ({
    __proto__: dart.getMethods(math_expressions.Root.__proto__),
    derive: dart.fnType(math_expressions.Expression, [core.String]),
    evaluate: dart.fnType(dart.dynamic, [math_expressions.EvaluationType, math_expressions.ContextModel]),
    asPower: dart.fnType(math_expressions.Expression, [])
  }));
  dart.setGetterSignature(math_expressions.Root, () => ({
    __proto__: dart.getGetters(math_expressions.Root.__proto__),
    n: core.int,
    arg: math_expressions.Expression
  }));
  dart.setSetterSignature(math_expressions.Root, () => ({
    __proto__: dart.getSetters(math_expressions.Root.__proto__),
    n: core.int
  }));
  dart.setLibraryUri(math_expressions.Root, I[1]);
  dart.setFieldSignature(math_expressions.Root, () => ({
    __proto__: dart.getFields(math_expressions.Root.__proto__),
    [__Root_n]: dart.fieldType(dart.nullable(core.int)),
    [__Root_n_isSet]: dart.fieldType(core.bool)
  }));
  dart.defineExtensionMethods(math_expressions.Root, ['toString']);
  math_expressions.Sqrt = class Sqrt extends math_expressions.Root {
    simplify() {
      let argSimpl = this.arg.simplify();
      if (math_expressions.Power.is(argSimpl)) {
        let exponent = argSimpl.second;
        if (math_expressions.Number.is(exponent)) {
          if (dart.equals(exponent.value, 2)) {
            return argSimpl.first;
          }
        }
      }
      if (dart.test(this[_isNumber](argSimpl, 0))) {
        return new math_expressions.Number.new(0);
      }
      if (dart.test(this[_isNumber](argSimpl, 1))) {
        return new math_expressions.Number.new(1);
      }
      return new math_expressions.Sqrt.new(argSimpl);
    }
    evaluate(type, context) {
      if (type == null) dart.nullFailed(I[3], 538, 35, "type");
      if (context == null) dart.nullFailed(I[3], 538, 54, "context");
      let argEval = this.arg.evaluate(type, context);
      if (type == math_expressions.EvaluationType.REAL) {
        return math.sqrt(core.num.as(argEval));
      }
      if (type == math_expressions.EvaluationType.VECTOR) {
      }
      if (type == math_expressions.EvaluationType.INTERVAL) {
        return new math_expressions.Interval.new(math.sqrt(core.num.as(dart.dload(argEval, 'min'))), math.sqrt(core.num.as(dart.dload(argEval, 'max'))));
      }
      dart.throw(new core.UnimplementedError.new("Can not evaluate " + dart.str(this.name) + " on " + dart.str(type) + " yet."));
    }
    toString() {
      return "sqrt(" + dart.str(this.arg) + ")";
    }
  };
  (math_expressions.Sqrt.new = function(arg) {
    if (arg == null) dart.nullFailed(I[3], 502, 19, "arg");
    math_expressions.Sqrt.__proto__.sqrt.call(this, arg);
    ;
  }).prototype = math_expressions.Sqrt.prototype;
  dart.addTypeTests(math_expressions.Sqrt);
  dart.addTypeCaches(math_expressions.Sqrt);
  dart.setLibraryUri(math_expressions.Sqrt, I[1]);
  dart.defineExtensionMethods(math_expressions.Sqrt, ['toString']);
  math_expressions.Sin = class Sin extends math_expressions.DefaultFunction {
    get arg() {
      return this.getParam(0);
    }
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[3], 570, 28, "toVar");
      return new math_expressions.Cos.new(this.arg)['*'](this.arg.derive(toVar));
    }
    simplify() {
      let argSimpl = this.arg.simplify();
      if (dart.test(this[_isNumber](argSimpl, 0))) {
        return new math_expressions.Number.new(0);
      }
      return new math_expressions.Sin.new(argSimpl);
    }
    evaluate(type, context) {
      if (type == null) dart.nullFailed(I[3], 587, 35, "type");
      if (context == null) dart.nullFailed(I[3], 587, 54, "context");
      let argEval = this.arg.evaluate(type, context);
      if (type == math_expressions.EvaluationType.REAL) {
        if (dart.equals(dart.dsend(dart.dsend(dart.dsend(argEval, '/', [3.141592653589793]), 'abs', []), '%', [1]), 0)) {
          return 0.0;
        }
        return math.sin(core.num.as(argEval));
      }
      if (type == math_expressions.EvaluationType.VECTOR) {
      }
      if (type == math_expressions.EvaluationType.INTERVAL) {
      }
      dart.throw(new core.UnimplementedError.new("Can not evaluate " + dart.str(this.name) + " on " + dart.str(type) + " yet."));
    }
  };
  (math_expressions.Sin.new = function(arg) {
    if (arg == null) dart.nullFailed(I[3], 564, 18, "arg");
    math_expressions.Sin.__proto__._unary.call(this, "sin", arg);
    ;
  }).prototype = math_expressions.Sin.prototype;
  dart.addTypeTests(math_expressions.Sin);
  dart.addTypeCaches(math_expressions.Sin);
  dart.setMethodSignature(math_expressions.Sin, () => ({
    __proto__: dart.getMethods(math_expressions.Sin.__proto__),
    derive: dart.fnType(math_expressions.Expression, [core.String]),
    evaluate: dart.fnType(dart.dynamic, [math_expressions.EvaluationType, math_expressions.ContextModel])
  }));
  dart.setGetterSignature(math_expressions.Sin, () => ({
    __proto__: dart.getGetters(math_expressions.Sin.__proto__),
    arg: math_expressions.Expression
  }));
  dart.setLibraryUri(math_expressions.Sin, I[1]);
  math_expressions.Cos = class Cos extends math_expressions.DefaultFunction {
    get arg() {
      return this.getParam(0);
    }
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[3], 621, 28, "toVar");
      return new math_expressions.Sin.new(this.arg)._negate()['*'](this.arg.derive(toVar));
    }
    simplify() {
      let argSimpl = this.arg.simplify();
      if (dart.test(this[_isNumber](argSimpl, 0))) {
        return new math_expressions.Number.new(1);
      }
      return new math_expressions.Cos.new(argSimpl);
    }
    evaluate(type, context) {
      if (type == null) dart.nullFailed(I[3], 638, 35, "type");
      if (context == null) dart.nullFailed(I[3], 638, 54, "context");
      let argEval = this.arg.evaluate(type, context);
      if (type == math_expressions.EvaluationType.REAL) {
        if (dart.equals(dart.dsend(dart.dsend(dart.dsend(dart.dsend(argEval, '-', [3.141592653589793 / 2]), '/', [3.141592653589793]), 'abs', []), '%', [1]), 0)) {
          return 0.0;
        }
        return math.cos(core.num.as(argEval));
      }
      if (type == math_expressions.EvaluationType.VECTOR) {
      }
      if (type == math_expressions.EvaluationType.INTERVAL) {
      }
      dart.throw(new core.UnimplementedError.new("Can not evaluate " + dart.str(this.name) + " on " + dart.str(type) + " yet."));
    }
  };
  (math_expressions.Cos.new = function(arg) {
    if (arg == null) dart.nullFailed(I[3], 615, 18, "arg");
    math_expressions.Cos.__proto__._unary.call(this, "cos", arg);
    ;
  }).prototype = math_expressions.Cos.prototype;
  dart.addTypeTests(math_expressions.Cos);
  dart.addTypeCaches(math_expressions.Cos);
  dart.setMethodSignature(math_expressions.Cos, () => ({
    __proto__: dart.getMethods(math_expressions.Cos.__proto__),
    derive: dart.fnType(math_expressions.Expression, [core.String]),
    evaluate: dart.fnType(dart.dynamic, [math_expressions.EvaluationType, math_expressions.ContextModel])
  }));
  dart.setGetterSignature(math_expressions.Cos, () => ({
    __proto__: dart.getGetters(math_expressions.Cos.__proto__),
    arg: math_expressions.Expression
  }));
  dart.setLibraryUri(math_expressions.Cos, I[1]);
  math_expressions.Tan = class Tan extends math_expressions.DefaultFunction {
    get arg() {
      return this.getParam(0);
    }
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[3], 673, 28, "toVar");
      return this.asSinCos().derive(toVar);
    }
    simplify() {
      let argSimpl = this.arg.simplify();
      if (dart.test(this[_isNumber](argSimpl, 0))) {
        return new math_expressions.Number.new(0);
      }
      return new math_expressions.Tan.new(argSimpl);
    }
    evaluate(type, context) {
      if (type == null) dart.nullFailed(I[3], 690, 35, "type");
      if (context == null) dart.nullFailed(I[3], 690, 54, "context");
      let argEval = this.arg.evaluate(type, context);
      if (type == math_expressions.EvaluationType.REAL) {
        if (dart.equals(dart.dsend(dart.dsend(dart.dsend(argEval, '/', [3.141592653589793]), 'abs', []), '%', [1]), 0)) {
          return 0.0;
        }
        return math.tan(core.num.as(argEval));
      }
      if (type == math_expressions.EvaluationType.VECTOR) {
      }
      dart.throw(new core.UnimplementedError.new("Can not evaluate " + dart.str(this.name) + " on " + dart.str(type) + " yet."));
    }
    asSinCos() {
      return new math_expressions.Sin.new(this.arg)['/'](new math_expressions.Cos.new(this.arg));
    }
  };
  (math_expressions.Tan.new = function(arg) {
    if (arg == null) dart.nullFailed(I[3], 667, 18, "arg");
    math_expressions.Tan.__proto__._unary.call(this, "tan", arg);
    ;
  }).prototype = math_expressions.Tan.prototype;
  dart.addTypeTests(math_expressions.Tan);
  dart.addTypeCaches(math_expressions.Tan);
  dart.setMethodSignature(math_expressions.Tan, () => ({
    __proto__: dart.getMethods(math_expressions.Tan.__proto__),
    derive: dart.fnType(math_expressions.Expression, [core.String]),
    evaluate: dart.fnType(dart.dynamic, [math_expressions.EvaluationType, math_expressions.ContextModel]),
    asSinCos: dart.fnType(math_expressions.Expression, [])
  }));
  dart.setGetterSignature(math_expressions.Tan, () => ({
    __proto__: dart.getGetters(math_expressions.Tan.__proto__),
    arg: math_expressions.Expression
  }));
  dart.setLibraryUri(math_expressions.Tan, I[1]);
  math_expressions.Asin = class Asin extends math_expressions.DefaultFunction {
    get arg() {
      return this.getParam(0);
    }
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[3], 723, 28, "toVar");
      return new math_expressions.Number.new(1)['/'](new math_expressions.Sqrt.new(new math_expressions.Number.new(1)['-'](this.arg['^'](new math_expressions.Number.new(2)))));
    }
    simplify() {
      return new math_expressions.Asin.new(this.arg.simplify());
    }
    evaluate(type, context) {
      if (type == null) dart.nullFailed(I[3], 733, 35, "type");
      if (context == null) dart.nullFailed(I[3], 733, 54, "context");
      let argEval = this.arg.evaluate(type, context);
      if (type == math_expressions.EvaluationType.REAL) {
        return math.asin(core.num.as(argEval));
      }
      dart.throw(new core.UnimplementedError.new("Can not evaluate " + dart.str(this.name) + " on " + dart.str(type) + " yet."));
    }
  };
  (math_expressions.Asin.new = function(arg) {
    if (arg == null) dart.nullFailed(I[3], 717, 19, "arg");
    math_expressions.Asin.__proto__._unary.call(this, "arcsin", arg);
    ;
  }).prototype = math_expressions.Asin.prototype;
  dart.addTypeTests(math_expressions.Asin);
  dart.addTypeCaches(math_expressions.Asin);
  dart.setMethodSignature(math_expressions.Asin, () => ({
    __proto__: dart.getMethods(math_expressions.Asin.__proto__),
    derive: dart.fnType(math_expressions.Expression, [core.String]),
    evaluate: dart.fnType(dart.dynamic, [math_expressions.EvaluationType, math_expressions.ContextModel])
  }));
  dart.setGetterSignature(math_expressions.Asin, () => ({
    __proto__: dart.getGetters(math_expressions.Asin.__proto__),
    arg: math_expressions.Expression
  }));
  dart.setLibraryUri(math_expressions.Asin, I[1]);
  math_expressions.Acos = class Acos extends math_expressions.DefaultFunction {
    get arg() {
      return this.getParam(0);
    }
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[3], 754, 28, "toVar");
      return new math_expressions.Number.new(1)._negate()['/'](new math_expressions.Sqrt.new(new math_expressions.Number.new(1)['-'](this.arg['^'](new math_expressions.Number.new(2)))));
    }
    simplify() {
      return new math_expressions.Acos.new(this.arg.simplify());
    }
    evaluate(type, context) {
      if (type == null) dart.nullFailed(I[3], 764, 35, "type");
      if (context == null) dart.nullFailed(I[3], 764, 54, "context");
      let argEval = this.arg.evaluate(type, context);
      if (type == math_expressions.EvaluationType.REAL) {
        return math.acos(core.num.as(argEval));
      }
      dart.throw(new core.UnimplementedError.new("Can not evaluate " + dart.str(this.name) + " on " + dart.str(type) + " yet."));
    }
  };
  (math_expressions.Acos.new = function(arg) {
    if (arg == null) dart.nullFailed(I[3], 748, 19, "arg");
    math_expressions.Acos.__proto__._unary.call(this, "arccos", arg);
    ;
  }).prototype = math_expressions.Acos.prototype;
  dart.addTypeTests(math_expressions.Acos);
  dart.addTypeCaches(math_expressions.Acos);
  dart.setMethodSignature(math_expressions.Acos, () => ({
    __proto__: dart.getMethods(math_expressions.Acos.__proto__),
    derive: dart.fnType(math_expressions.Expression, [core.String]),
    evaluate: dart.fnType(dart.dynamic, [math_expressions.EvaluationType, math_expressions.ContextModel])
  }));
  dart.setGetterSignature(math_expressions.Acos, () => ({
    __proto__: dart.getGetters(math_expressions.Acos.__proto__),
    arg: math_expressions.Expression
  }));
  dart.setLibraryUri(math_expressions.Acos, I[1]);
  math_expressions.Atan = class Atan extends math_expressions.DefaultFunction {
    get arg() {
      return this.getParam(0);
    }
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[3], 785, 28, "toVar");
      return new math_expressions.Number.new(1)['/'](new math_expressions.Number.new(1)['+'](this.arg['^'](new math_expressions.Number.new(2))));
    }
    simplify() {
      return new math_expressions.Atan.new(this.arg.simplify());
    }
    evaluate(type, context) {
      if (type == null) dart.nullFailed(I[3], 795, 35, "type");
      if (context == null) dart.nullFailed(I[3], 795, 54, "context");
      let argEval = this.arg.evaluate(type, context);
      if (type == math_expressions.EvaluationType.REAL) {
        return math.atan(core.num.as(argEval));
      }
      dart.throw(new core.UnimplementedError.new("Can not evaluate " + dart.str(this.name) + " on " + dart.str(type) + " yet."));
    }
  };
  (math_expressions.Atan.new = function(arg) {
    if (arg == null) dart.nullFailed(I[3], 779, 19, "arg");
    math_expressions.Atan.__proto__._unary.call(this, "arctan", arg);
    ;
  }).prototype = math_expressions.Atan.prototype;
  dart.addTypeTests(math_expressions.Atan);
  dart.addTypeCaches(math_expressions.Atan);
  dart.setMethodSignature(math_expressions.Atan, () => ({
    __proto__: dart.getMethods(math_expressions.Atan.__proto__),
    derive: dart.fnType(math_expressions.Expression, [core.String]),
    evaluate: dart.fnType(dart.dynamic, [math_expressions.EvaluationType, math_expressions.ContextModel])
  }));
  dart.setGetterSignature(math_expressions.Atan, () => ({
    __proto__: dart.getGetters(math_expressions.Atan.__proto__),
    arg: math_expressions.Expression
  }));
  dart.setLibraryUri(math_expressions.Atan, I[1]);
  math_expressions.Abs = class Abs extends math_expressions.DefaultFunction {
    get arg() {
      return this.getParam(0);
    }
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[3], 818, 28, "toVar");
      return new math_expressions.Sgn.new(this.arg)['*'](this.arg.derive(toVar));
    }
    simplify() {
      return new math_expressions.Abs.new(this.arg.simplify());
    }
    evaluate(type, context) {
      if (type == null) dart.nullFailed(I[3], 825, 35, "type");
      if (context == null) dart.nullFailed(I[3], 825, 54, "context");
      let argEval = this.arg.evaluate(type, context);
      if (type == math_expressions.EvaluationType.REAL) {
        return dart.dsend(argEval, 'abs', []);
      }
      if (type == math_expressions.EvaluationType.VECTOR) {
      }
      dart.throw(new core.UnimplementedError.new("Can not evaluate " + dart.str(this.name) + " on " + dart.str(type) + " yet."));
    }
  };
  (math_expressions.Abs.new = function(arg) {
    if (arg == null) dart.nullFailed(I[3], 810, 18, "arg");
    math_expressions.Abs.__proto__._unary.call(this, "abs", arg);
    ;
  }).prototype = math_expressions.Abs.prototype;
  dart.addTypeTests(math_expressions.Abs);
  dart.addTypeCaches(math_expressions.Abs);
  dart.setMethodSignature(math_expressions.Abs, () => ({
    __proto__: dart.getMethods(math_expressions.Abs.__proto__),
    derive: dart.fnType(math_expressions.Expression, [core.String]),
    evaluate: dart.fnType(dart.dynamic, [math_expressions.EvaluationType, math_expressions.ContextModel])
  }));
  dart.setGetterSignature(math_expressions.Abs, () => ({
    __proto__: dart.getGetters(math_expressions.Abs.__proto__),
    arg: math_expressions.Expression
  }));
  dart.setLibraryUri(math_expressions.Abs, I[1]);
  math_expressions.Ceil = class Ceil extends math_expressions.DefaultFunction {
    get arg() {
      return this.getParam(0);
    }
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[3], 851, 28, "toVar");
      return new math_expressions.Number.new(0);
    }
    simplify() {
      let sarg = this.arg.simplify();
      return math_expressions.Floor.is(sarg) || math_expressions.Ceil.is(sarg) ? sarg : new math_expressions.Ceil.new(sarg);
    }
    evaluate(type, context) {
      if (type == null) dart.nullFailed(I[3], 864, 35, "type");
      if (context == null) dart.nullFailed(I[3], 864, 54, "context");
      let argEval = this.arg.evaluate(type, context);
      if (type == math_expressions.EvaluationType.REAL) {
        return dart.dsend(dart.dsend(argEval, 'ceil', []), 'toDouble', []);
      }
      if (type == math_expressions.EvaluationType.VECTOR) {
      }
      dart.throw(new core.UnimplementedError.new("Can not evaluate " + dart.str(this.name) + " on " + dart.str(type) + " yet."));
    }
  };
  (math_expressions.Ceil.new = function(arg) {
    if (arg == null) dart.nullFailed(I[3], 843, 19, "arg");
    math_expressions.Ceil.__proto__._unary.call(this, "ceil", arg);
    ;
  }).prototype = math_expressions.Ceil.prototype;
  dart.addTypeTests(math_expressions.Ceil);
  dart.addTypeCaches(math_expressions.Ceil);
  dart.setMethodSignature(math_expressions.Ceil, () => ({
    __proto__: dart.getMethods(math_expressions.Ceil.__proto__),
    derive: dart.fnType(math_expressions.Expression, [core.String]),
    evaluate: dart.fnType(dart.dynamic, [math_expressions.EvaluationType, math_expressions.ContextModel])
  }));
  dart.setGetterSignature(math_expressions.Ceil, () => ({
    __proto__: dart.getGetters(math_expressions.Ceil.__proto__),
    arg: math_expressions.Expression
  }));
  dart.setLibraryUri(math_expressions.Ceil, I[1]);
  math_expressions.Floor = class Floor extends math_expressions.DefaultFunction {
    get arg() {
      return this.getParam(0);
    }
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[3], 890, 28, "toVar");
      return new math_expressions.Number.new(0);
    }
    simplify() {
      let sarg = this.arg.simplify();
      return math_expressions.Floor.is(sarg) || math_expressions.Ceil.is(sarg) ? sarg : new math_expressions.Floor.new(sarg);
    }
    evaluate(type, context) {
      if (type == null) dart.nullFailed(I[3], 903, 35, "type");
      if (context == null) dart.nullFailed(I[3], 903, 54, "context");
      let argEval = this.arg.evaluate(type, context);
      if (type == math_expressions.EvaluationType.REAL) {
        return dart.dsend(dart.dsend(argEval, 'floor', []), 'toDouble', []);
      }
      if (type == math_expressions.EvaluationType.VECTOR) {
      }
      dart.throw(new core.UnimplementedError.new("Can not evaluate " + dart.str(this.name) + " on " + dart.str(type) + " yet."));
    }
  };
  (math_expressions.Floor.new = function(arg) {
    if (arg == null) dart.nullFailed(I[3], 882, 20, "arg");
    math_expressions.Floor.__proto__._unary.call(this, "floor", arg);
    ;
  }).prototype = math_expressions.Floor.prototype;
  dart.addTypeTests(math_expressions.Floor);
  dart.addTypeCaches(math_expressions.Floor);
  dart.setMethodSignature(math_expressions.Floor, () => ({
    __proto__: dart.getMethods(math_expressions.Floor.__proto__),
    derive: dart.fnType(math_expressions.Expression, [core.String]),
    evaluate: dart.fnType(dart.dynamic, [math_expressions.EvaluationType, math_expressions.ContextModel])
  }));
  dart.setGetterSignature(math_expressions.Floor, () => ({
    __proto__: dart.getGetters(math_expressions.Floor.__proto__),
    arg: math_expressions.Expression
  }));
  dart.setLibraryUri(math_expressions.Floor, I[1]);
  math_expressions.Sgn = class Sgn extends math_expressions.DefaultFunction {
    get arg() {
      return this.getParam(0);
    }
    derive(toVar) {
      if (toVar == null) dart.nullFailed(I[3], 928, 28, "toVar");
      return new math_expressions.Number.new(0);
    }
    simplify() {
      return new math_expressions.Sgn.new(this.arg.simplify());
    }
    evaluate(type, context) {
      if (type == null) dart.nullFailed(I[3], 934, 35, "type");
      if (context == null) dart.nullFailed(I[3], 934, 54, "context");
      let argEval = this.arg.evaluate(type, context);
      if (type == math_expressions.EvaluationType.REAL) {
        if (dart.dtest(dart.dsend(argEval, '<', [0]))) return -1.0;
        if (dart.equals(argEval, 0)) return 0.0;
        if (dart.dtest(dart.dsend(argEval, '>', [0]))) return 1.0;
      }
      dart.throw(new core.UnimplementedError.new("Can not evaluate " + dart.str(this.name) + " on " + dart.str(type) + " yet."));
    }
  };
  (math_expressions.Sgn.new = function(arg) {
    if (arg == null) dart.nullFailed(I[3], 921, 18, "arg");
    math_expressions.Sgn.__proto__._unary.call(this, "sgn", arg);
    ;
  }).prototype = math_expressions.Sgn.prototype;
  dart.addTypeTests(math_expressions.Sgn);
  dart.addTypeCaches(math_expressions.Sgn);
  dart.setMethodSignature(math_expressions.Sgn, () => ({
    __proto__: dart.getMethods(math_expressions.Sgn.__proto__),
    derive: dart.fnType(math_expressions.Expression, [core.String]),
    evaluate: dart.fnType(dart.dynamic, [math_expressions.EvaluationType, math_expressions.ContextModel])
  }));
  dart.setGetterSignature(math_expressions.Sgn, () => ({
    __proto__: dart.getGetters(math_expressions.Sgn.__proto__),
    arg: math_expressions.Expression
  }));
  dart.setLibraryUri(math_expressions.Sgn, I[1]);
  var lex = dart.privateName(math_expressions, "Parser.lex");
  var TokenType_function = dart.privateName(math_expressions, "TokenType.function");
  var TokenType_operator = dart.privateName(math_expressions, "TokenType.operator");
  var TokenType_leftAssociative = dart.privateName(math_expressions, "TokenType.leftAssociative");
  var TokenType_priority = dart.privateName(math_expressions, "TokenType.priority");
  var TokenType_value = dart.privateName(math_expressions, "TokenType.value");
  math_expressions.Parser = class Parser extends core.Object {
    get lex() {
      return this[lex];
    }
    set lex(value) {
      super.lex = value;
    }
    parse(inputString) {
      if (inputString == null) dart.nullFailed(I[4], 22, 27, "inputString");
      if (inputString[$trim]()[$isEmpty]) {
        dart.throw(new core.FormatException.new("The given input string was empty."));
      }
      let exprStack = T.JSArrayOfExpression().of([]);
      let inputStream = this.lex.tokenizeToRPN(inputString);
      for (let currToken of inputStream) {
        let currExpr = null;
        let left = null;
        let right = null;
        switch (currToken.type) {
          case C[0] || CT.C0:
          {
            currExpr = new math_expressions.Number.new(core.double.parse(currToken.text));
            break;
          }
          case C[1] || CT.C1:
          {
            currExpr = new math_expressions.Variable.new(currToken.text);
            break;
          }
          case C[2] || CT.C2:
          {
            currExpr = exprStack[$removeLast]()._negate();
            break;
          }
          case C[3] || CT.C3:
          {
            right = exprStack[$removeLast]();
            left = exprStack[$removeLast]();
            currExpr = left['+'](right);
            break;
          }
          case C[4] || CT.C4:
          {
            right = exprStack[$removeLast]();
            left = exprStack[$removeLast]();
            currExpr = left['-'](right);
            break;
          }
          case C[5] || CT.C5:
          {
            right = exprStack[$removeLast]();
            left = exprStack[$removeLast]();
            currExpr = left['*'](right);
            break;
          }
          case C[6] || CT.C6:
          {
            right = exprStack[$removeLast]();
            left = exprStack[$removeLast]();
            currExpr = left['/'](right);
            break;
          }
          case C[7] || CT.C7:
          {
            right = exprStack[$removeLast]();
            left = exprStack[$removeLast]();
            currExpr = left['%'](right);
            break;
          }
          case C[8] || CT.C8:
          {
            right = exprStack[$removeLast]();
            left = exprStack[$removeLast]();
            currExpr = left['^'](right);
            break;
          }
          case C[9] || CT.C9:
          {
            currExpr = new math_expressions.Exponential.new(exprStack[$removeLast]());
            break;
          }
          case C[10] || CT.C10:
          {
            right = exprStack[$removeLast]();
            left = exprStack[$removeLast]();
            currExpr = new math_expressions.Log.new(left, right);
            break;
          }
          case C[11] || CT.C11:
          {
            currExpr = new math_expressions.Ln.new(exprStack[$removeLast]());
            break;
          }
          case C[12] || CT.C12:
          {
            currExpr = new math_expressions.Sqrt.new(exprStack[$removeLast]());
            break;
          }
          case C[13] || CT.C13:
          {
            right = exprStack[$removeLast]();
            left = exprStack[$removeLast]();
            currExpr = new math_expressions.Root.fromExpr(math_expressions.Number.as(left), right);
            break;
          }
          case C[14] || CT.C14:
          {
            currExpr = new math_expressions.Sin.new(exprStack[$removeLast]());
            break;
          }
          case C[15] || CT.C15:
          {
            currExpr = new math_expressions.Cos.new(exprStack[$removeLast]());
            break;
          }
          case C[16] || CT.C16:
          {
            currExpr = new math_expressions.Tan.new(exprStack[$removeLast]());
            break;
          }
          case C[17] || CT.C17:
          {
            currExpr = new math_expressions.Asin.new(exprStack[$removeLast]());
            break;
          }
          case C[18] || CT.C18:
          {
            currExpr = new math_expressions.Acos.new(exprStack[$removeLast]());
            break;
          }
          case C[19] || CT.C19:
          {
            currExpr = new math_expressions.Atan.new(exprStack[$removeLast]());
            break;
          }
          case C[20] || CT.C20:
          {
            currExpr = new math_expressions.Abs.new(exprStack[$removeLast]());
            break;
          }
          case C[21] || CT.C21:
          {
            currExpr = new math_expressions.Ceil.new(exprStack[$removeLast]());
            break;
          }
          case C[22] || CT.C22:
          {
            currExpr = new math_expressions.Floor.new(exprStack[$removeLast]());
            break;
          }
          case C[23] || CT.C23:
          {
            currExpr = new math_expressions.Sgn.new(exprStack[$removeLast]());
            break;
          }
          default:
          {
            dart.throw(new core.FormatException.new("Unsupported token: " + dart.str(currToken)));
          }
        }
        exprStack[$add](currExpr);
      }
      if (dart.notNull(exprStack[$length]) > 1) {
        dart.throw(new core.FormatException.new("The input String is not a correct expression"));
      }
      return exprStack[$last];
    }
  };
  (math_expressions.Parser.new = function() {
    this[lex] = new math_expressions.Lexer.new();
    ;
  }).prototype = math_expressions.Parser.prototype;
  dart.addTypeTests(math_expressions.Parser);
  dart.addTypeCaches(math_expressions.Parser);
  dart.setMethodSignature(math_expressions.Parser, () => ({
    __proto__: dart.getMethods(math_expressions.Parser.__proto__),
    parse: dart.fnType(math_expressions.Expression, [core.String])
  }));
  dart.setLibraryUri(math_expressions.Parser, I[1]);
  dart.setFieldSignature(math_expressions.Parser, () => ({
    __proto__: dart.getFields(math_expressions.Parser.__proto__),
    lex: dart.finalFieldType(math_expressions.Lexer)
  }));
  var keywords = dart.privateName(math_expressions, "Lexer.keywords");
  var intBuffer = dart.privateName(math_expressions, "Lexer.intBuffer");
  var varBuffer = dart.privateName(math_expressions, "Lexer.varBuffer");
  var _doIntBuffer = dart.privateName(math_expressions, "_doIntBuffer");
  var _doVarBuffer = dart.privateName(math_expressions, "_doVarBuffer");
  math_expressions.Lexer = class Lexer extends core.Object {
    get keywords() {
      return this[keywords];
    }
    set keywords(value) {
      super.keywords = value;
    }
    get intBuffer() {
      return this[intBuffer];
    }
    set intBuffer(value) {
      this[intBuffer] = value;
    }
    get varBuffer() {
      return this[varBuffer];
    }
    set varBuffer(value) {
      this[varBuffer] = value;
    }
    tokenize(inputString) {
      if (inputString == null) dart.nullFailed(I[4], 184, 31, "inputString");
      let tempTokenStream = T.JSArrayOfToken().of([]);
      let clearedString = inputString[$replaceAll](" ", "")[$trim]();
      let iter = clearedString[$runes].iterator;
      while (dart.test(iter.moveNext())) {
        let si = iter.currentAsString;
        let keywordsContainsKey = this.keywords[$containsKey](si);
        if (si === "e" && this.varBuffer[$isNotEmpty]) {
          keywordsContainsKey = false;
        }
        if (dart.test(keywordsContainsKey)) {
          if (this.intBuffer[$isNotEmpty]) {
            this[_doIntBuffer](tempTokenStream);
          }
          if (this.varBuffer[$isNotEmpty]) {
            this[_doVarBuffer](tempTokenStream);
          }
          if (dart.equals(this.keywords[$_get](si), math_expressions.TokenType.POW) && dart.equals(tempTokenStream[$last].type, math_expressions.TokenType.EFUNC)) {
            this.varBuffer = "";
          } else {
            tempTokenStream[$add](new math_expressions.Token.new(si, dart.nullCheck(this.keywords[$_get](si))));
          }
        } else {
          let sb = new core.StringBuffer.new(this.intBuffer);
          try {
            core.int.parse(si);
            sb.write(si);
            this.intBuffer = sb.toString();
            if (this.varBuffer[$isNotEmpty]) {
              this[_doVarBuffer](tempTokenStream);
            }
          } catch (e) {
            let ex = dart.getThrown(e);
            if (core.FormatException.is(ex)) {
              if (si === ".") {
                sb.write(si);
                this.intBuffer = sb.toString();
                continue;
              }
              sb = new core.StringBuffer.new(this.varBuffer);
              if (this.intBuffer[$isNotEmpty]) {
                this[_doIntBuffer](tempTokenStream);
                sb.write(si);
                this.varBuffer = sb.toString();
              } else {
                sb.write(si);
                this.varBuffer = sb.toString();
              }
            } else
              throw e;
          }
        }
      }
      if (this.intBuffer[$isNotEmpty]) {
        this[_doIntBuffer](tempTokenStream);
      }
      if (this.varBuffer[$isNotEmpty]) {
        this[_doVarBuffer](tempTokenStream);
      }
      return tempTokenStream;
    }
    [_doIntBuffer](stream) {
      if (stream == null) dart.nullFailed(I[4], 275, 33, "stream");
      stream[$add](new math_expressions.Token.new(this.intBuffer, math_expressions.TokenType.VAL));
      this.intBuffer = "";
    }
    [_doVarBuffer](stream) {
      if (stream == null) dart.nullFailed(I[4], 282, 33, "stream");
      if (dart.test(this.keywords[$containsKey](this.varBuffer))) {
        stream[$add](new math_expressions.Token.new(this.varBuffer, dart.nullCheck(this.keywords[$_get](this.varBuffer))));
      } else {
        stream[$add](new math_expressions.Token.new(this.varBuffer, math_expressions.TokenType.VAR));
      }
      this.varBuffer = "";
    }
    shuntingYard(stream) {
      if (stream == null) dart.nullFailed(I[4], 294, 40, "stream");
      if (dart.test(stream[$isEmpty])) {
        dart.throw(new core.FormatException.new("The given tokenStream was empty."));
      }
      let outputStream = T.JSArrayOfToken().of([]);
      let operatorBuffer = T.JSArrayOfToken().of([]);
      let prevToken = null;
      for (let curToken of stream) {
        if (dart.equals(curToken.type, math_expressions.TokenType.VAL) || dart.equals(curToken.type, math_expressions.TokenType.VAR)) {
          outputStream[$add](curToken);
          prevToken = curToken;
          continue;
        }
        if (dart.test(curToken.type.function)) {
          operatorBuffer[$add](curToken);
          prevToken = curToken;
          continue;
        }
        if (dart.equals(curToken.type, math_expressions.TokenType.SEPAR)) {
          while (dart.test(operatorBuffer[$isNotEmpty]) && !dart.equals(operatorBuffer[$last].type, math_expressions.TokenType.LBRACE)) {
            outputStream[$add](operatorBuffer[$removeLast]());
          }
          if (dart.test(operatorBuffer[$isNotEmpty]) && !dart.equals(operatorBuffer[$last].type, math_expressions.TokenType.LBRACE)) {
            dart.throw(new core.FormatException.new("Misplaced separator or mismatched parenthesis."));
          }
          prevToken = curToken;
          continue;
        }
        if (dart.equals(curToken.type, math_expressions.TokenType.MINUS) && (prevToken == null || dart.test(prevToken.type.operator) || dart.equals(prevToken.type, math_expressions.TokenType.LBRACE))) {
          let newToken = new math_expressions.Token.new(curToken.text, math_expressions.TokenType.UNMINUS);
          operatorBuffer[$add](newToken);
          prevToken = newToken;
          continue;
        }
        if (dart.test(curToken.type.operator)) {
          while (dart.test(operatorBuffer[$isNotEmpty]) && (dart.test(curToken.type.leftAssociative) && dart.notNull(curToken.type.priority) <= dart.notNull(operatorBuffer[$last].type.priority) || !dart.test(curToken.type.leftAssociative) && dart.notNull(curToken.type.priority) < dart.notNull(operatorBuffer[$last].type.priority))) {
            outputStream[$add](operatorBuffer[$removeLast]());
          }
          operatorBuffer[$add](curToken);
          prevToken = curToken;
          continue;
        }
        if (dart.equals(curToken.type, math_expressions.TokenType.LBRACE)) {
          operatorBuffer[$add](curToken);
          prevToken = curToken;
          continue;
        }
        if (dart.equals(curToken.type, math_expressions.TokenType.RBRACE)) {
          while (dart.test(operatorBuffer[$isNotEmpty]) && !dart.equals(operatorBuffer[$last].type, math_expressions.TokenType.LBRACE)) {
            outputStream[$add](operatorBuffer[$removeLast]());
          }
          if (dart.test(operatorBuffer[$isEmpty]) || !dart.equals(operatorBuffer[$removeLast]().type, math_expressions.TokenType.LBRACE)) {
            dart.throw(new core.FormatException.new("Mismatched parenthesis."));
          }
          if (dart.test(operatorBuffer[$isNotEmpty]) && dart.test(operatorBuffer[$last].type.function)) {
            outputStream[$add](operatorBuffer[$removeLast]());
          }
        }
        prevToken = curToken;
      }
      while (dart.test(operatorBuffer[$isNotEmpty])) {
        if (dart.equals(operatorBuffer[$last].type, math_expressions.TokenType.LBRACE) || dart.equals(operatorBuffer[$last].type, math_expressions.TokenType.RBRACE)) {
          dart.throw(new core.FormatException.new("Mismatched parenthesis."));
        }
        outputStream[$add](operatorBuffer[$removeLast]());
      }
      return outputStream;
    }
    tokenizeToRPN(inputString) {
      if (inputString == null) dart.nullFailed(I[4], 421, 36, "inputString");
      let infixStream = this.tokenize(inputString);
      return this.shuntingYard(infixStream);
    }
  };
  (math_expressions.Lexer.new = function() {
    this[keywords] = new (T.IdentityMapOfString$TokenType()).new();
    this[intBuffer] = "";
    this[varBuffer] = "";
    this.keywords[$_set]("+", math_expressions.TokenType.PLUS);
    this.keywords[$_set]("-", math_expressions.TokenType.MINUS);
    this.keywords[$_set]("*", math_expressions.TokenType.TIMES);
    this.keywords[$_set]("/", math_expressions.TokenType.DIV);
    this.keywords[$_set]("%", math_expressions.TokenType.MOD);
    this.keywords[$_set]("^", math_expressions.TokenType.POW);
    this.keywords[$_set]("nrt", math_expressions.TokenType.ROOT);
    this.keywords[$_set]("sqrt", math_expressions.TokenType.SQRT);
    this.keywords[$_set]("log", math_expressions.TokenType.LOG);
    this.keywords[$_set]("cos", math_expressions.TokenType.COS);
    this.keywords[$_set]("sin", math_expressions.TokenType.SIN);
    this.keywords[$_set]("tan", math_expressions.TokenType.TAN);
    this.keywords[$_set]("arccos", math_expressions.TokenType.ACOS);
    this.keywords[$_set]("arcsin", math_expressions.TokenType.ASIN);
    this.keywords[$_set]("arctan", math_expressions.TokenType.ATAN);
    this.keywords[$_set]("abs", math_expressions.TokenType.ABS);
    this.keywords[$_set]("ceil", math_expressions.TokenType.CEIL);
    this.keywords[$_set]("floor", math_expressions.TokenType.FLOOR);
    this.keywords[$_set]("sgn", math_expressions.TokenType.SGN);
    this.keywords[$_set]("ln", math_expressions.TokenType.LN);
    this.keywords[$_set]("e", math_expressions.TokenType.EFUNC);
    this.keywords[$_set]("(", math_expressions.TokenType.LBRACE);
    this.keywords[$_set](")", math_expressions.TokenType.RBRACE);
    this.keywords[$_set]("{", math_expressions.TokenType.LBRACE);
    this.keywords[$_set]("}", math_expressions.TokenType.RBRACE);
    this.keywords[$_set](",", math_expressions.TokenType.SEPAR);
  }).prototype = math_expressions.Lexer.prototype;
  dart.addTypeTests(math_expressions.Lexer);
  dart.addTypeCaches(math_expressions.Lexer);
  dart.setMethodSignature(math_expressions.Lexer, () => ({
    __proto__: dart.getMethods(math_expressions.Lexer.__proto__),
    tokenize: dart.fnType(core.List$(math_expressions.Token), [core.String]),
    [_doIntBuffer]: dart.fnType(dart.void, [core.List$(math_expressions.Token)]),
    [_doVarBuffer]: dart.fnType(dart.void, [core.List$(math_expressions.Token)]),
    shuntingYard: dart.fnType(core.List$(math_expressions.Token), [core.List$(math_expressions.Token)]),
    tokenizeToRPN: dart.fnType(core.List$(math_expressions.Token), [core.String])
  }));
  dart.setLibraryUri(math_expressions.Lexer, I[1]);
  dart.setFieldSignature(math_expressions.Lexer, () => ({
    __proto__: dart.getFields(math_expressions.Lexer.__proto__),
    keywords: dart.finalFieldType(core.Map$(core.String, math_expressions.TokenType)),
    intBuffer: dart.fieldType(core.String),
    varBuffer: dart.fieldType(core.String)
  }));
  var text$ = dart.privateName(math_expressions, "Token.text");
  var type$ = dart.privateName(math_expressions, "Token.type");
  math_expressions.Token = class Token extends core.Object {
    get text() {
      return this[text$];
    }
    set text(value) {
      super.text = value;
    }
    get type() {
      return this[type$];
    }
    set type(value) {
      super.type = value;
    }
    _equals(token) {
      if (token == null) return false;
      return math_expressions.Token.is(token) && token.text == this.text && dart.equals(token.type, this.type);
    }
    get hashCode() {
      let result = 17;
      result = 37 * result + dart.hashCode(this.text);
      result = 37 * result + dart.notNull(dart.hashCode(this.type));
      return result;
    }
    toString() {
      return "(" + dart.str(this.type) + ": " + dart.str(this.text) + ")";
    }
  };
  (math_expressions.Token.new = function(text, type) {
    if (text == null) dart.nullFailed(I[4], 436, 14, "text");
    if (type == null) dart.nullFailed(I[4], 436, 25, "type");
    this[text$] = text;
    this[type$] = type;
    ;
  }).prototype = math_expressions.Token.prototype;
  dart.addTypeTests(math_expressions.Token);
  dart.addTypeCaches(math_expressions.Token);
  dart.setLibraryUri(math_expressions.Token, I[1]);
  dart.setFieldSignature(math_expressions.Token, () => ({
    __proto__: dart.getFields(math_expressions.Token.__proto__),
    text: dart.finalFieldType(core.String),
    type: dart.finalFieldType(math_expressions.TokenType)
  }));
  dart.defineExtensionMethods(math_expressions.Token, ['_equals', 'toString']);
  dart.defineExtensionAccessors(math_expressions.Token, ['hashCode']);
  const value$0 = TokenType_value;
  const priority$ = TokenType_priority;
  const leftAssociative$ = TokenType_leftAssociative;
  const operator$ = TokenType_operator;
  const $function$ = TokenType_function;
  math_expressions.TokenType = class TokenType extends core.Object {
    get value() {
      return this[value$0];
    }
    set value(value) {
      super.value = value;
    }
    get priority() {
      return this[priority$];
    }
    set priority(value) {
      super.priority = value;
    }
    get leftAssociative() {
      return this[leftAssociative$];
    }
    set leftAssociative(value) {
      super.leftAssociative = value;
    }
    get operator() {
      return this[operator$];
    }
    set operator(value) {
      super.operator = value;
    }
    get function() {
      return this[$function$];
    }
    set function(value) {
      super.function = value;
    }
    toString() {
      return this.value;
    }
  };
  (math_expressions.TokenType._internal = function(value, priority, opts) {
    if (value == null) dart.nullFailed(I[4], 529, 34, "value");
    if (priority == null) dart.nullFailed(I[4], 529, 46, "priority");
    let leftAssociative = opts && 'leftAssociative' in opts ? opts.leftAssociative : true;
    if (leftAssociative == null) dart.nullFailed(I[4], 530, 13, "leftAssociative");
    let operator = opts && 'operator' in opts ? opts.operator : false;
    if (operator == null) dart.nullFailed(I[4], 531, 12, "operator");
    let $function = opts && 'function' in opts ? opts.function : false;
    if ($function == null) dart.nullFailed(I[4], 532, 12, "function");
    this[value$0] = value;
    this[priority$] = priority;
    this[leftAssociative$] = leftAssociative;
    this[operator$] = operator;
    this[$function$] = $function;
    ;
  }).prototype = math_expressions.TokenType.prototype;
  dart.addTypeTests(math_expressions.TokenType);
  dart.addTypeCaches(math_expressions.TokenType);
  dart.setLibraryUri(math_expressions.TokenType, I[1]);
  dart.setFieldSignature(math_expressions.TokenType, () => ({
    __proto__: dart.getFields(math_expressions.TokenType.__proto__),
    value: dart.finalFieldType(core.String),
    priority: dart.finalFieldType(core.int),
    leftAssociative: dart.finalFieldType(core.bool),
    operator: dart.finalFieldType(core.bool),
    function: dart.finalFieldType(core.bool)
  }));
  dart.defineExtensionMethods(math_expressions.TokenType, ['toString']);
  dart.defineLazy(math_expressions.TokenType, {
    /*math_expressions.TokenType.VAR*/get VAR() {
      return C[1] || CT.C1;
    },
    /*math_expressions.TokenType.VAL*/get VAL() {
      return C[0] || CT.C0;
    },
    /*math_expressions.TokenType.LBRACE*/get LBRACE() {
      return C[24] || CT.C24;
    },
    /*math_expressions.TokenType.RBRACE*/get RBRACE() {
      return C[25] || CT.C25;
    },
    /*math_expressions.TokenType.SEPAR*/get SEPAR() {
      return C[26] || CT.C26;
    },
    /*math_expressions.TokenType.PLUS*/get PLUS() {
      return C[3] || CT.C3;
    },
    /*math_expressions.TokenType.MINUS*/get MINUS() {
      return C[4] || CT.C4;
    },
    /*math_expressions.TokenType.TIMES*/get TIMES() {
      return C[5] || CT.C5;
    },
    /*math_expressions.TokenType.DIV*/get DIV() {
      return C[6] || CT.C6;
    },
    /*math_expressions.TokenType.MOD*/get MOD() {
      return C[7] || CT.C7;
    },
    /*math_expressions.TokenType.POW*/get POW() {
      return C[8] || CT.C8;
    },
    /*math_expressions.TokenType.UNMINUS*/get UNMINUS() {
      return C[2] || CT.C2;
    },
    /*math_expressions.TokenType.SQRT*/get SQRT() {
      return C[12] || CT.C12;
    },
    /*math_expressions.TokenType.ROOT*/get ROOT() {
      return C[13] || CT.C13;
    },
    /*math_expressions.TokenType.LOG*/get LOG() {
      return C[10] || CT.C10;
    },
    /*math_expressions.TokenType.LN*/get LN() {
      return C[11] || CT.C11;
    },
    /*math_expressions.TokenType.COS*/get COS() {
      return C[15] || CT.C15;
    },
    /*math_expressions.TokenType.SIN*/get SIN() {
      return C[14] || CT.C14;
    },
    /*math_expressions.TokenType.TAN*/get TAN() {
      return C[16] || CT.C16;
    },
    /*math_expressions.TokenType.ACOS*/get ACOS() {
      return C[18] || CT.C18;
    },
    /*math_expressions.TokenType.ASIN*/get ASIN() {
      return C[17] || CT.C17;
    },
    /*math_expressions.TokenType.ATAN*/get ATAN() {
      return C[19] || CT.C19;
    },
    /*math_expressions.TokenType.ABS*/get ABS() {
      return C[20] || CT.C20;
    },
    /*math_expressions.TokenType.CEIL*/get CEIL() {
      return C[21] || CT.C21;
    },
    /*math_expressions.TokenType.FLOOR*/get FLOOR() {
      return C[22] || CT.C22;
    },
    /*math_expressions.TokenType.SGN*/get SGN() {
      return C[23] || CT.C23;
    },
    /*math_expressions.TokenType.EFUNC*/get EFUNC() {
      return C[9] || CT.C9;
    }
  }, false);
  var _name$ = dart.privateName(math_expressions, "_name");
  math_expressions.EvaluationType = class EvaluationType extends core.Object {
    toString() {
      return this[_name$];
    }
  };
  (math_expressions.EvaluationType.new = function(index, _name) {
    if (index == null) dart.nullFailed(I[5], 15, 6, "index");
    if (_name == null) dart.nullFailed(I[5], 15, 6, "_name");
    this.index = index;
    this[_name$] = _name;
    ;
  }).prototype = math_expressions.EvaluationType.prototype;
  dart.addTypeTests(math_expressions.EvaluationType);
  dart.addTypeCaches(math_expressions.EvaluationType);
  dart.setLibraryUri(math_expressions.EvaluationType, I[1]);
  dart.setFieldSignature(math_expressions.EvaluationType, () => ({
    __proto__: dart.getFields(math_expressions.EvaluationType.__proto__),
    index: dart.finalFieldType(core.int),
    [_name$]: dart.finalFieldType(core.String)
  }));
  dart.defineExtensionMethods(math_expressions.EvaluationType, ['toString']);
  math_expressions.EvaluationType.REAL = C[27] || CT.C27;
  math_expressions.EvaluationType.VECTOR = C[28] || CT.C28;
  math_expressions.EvaluationType.INTERVAL = C[29] || CT.C29;
  math_expressions.EvaluationType.values = C[30] || CT.C30;
  var parentScope$ = dart.privateName(math_expressions, "ContextModel.parentScope");
  var variables = dart.privateName(math_expressions, "ContextModel.variables");
  var functions = dart.privateName(math_expressions, "ContextModel.functions");
  math_expressions.ContextModel = class ContextModel extends core.Object {
    get parentScope() {
      return this[parentScope$];
    }
    set parentScope(value) {
      this[parentScope$] = value;
    }
    get variables() {
      return this[variables];
    }
    set variables(value) {
      this[variables] = value;
    }
    get functions() {
      return this[functions];
    }
    set functions(value) {
      this[functions] = value;
    }
    createChildScope() {
      return new math_expressions.ContextModel._child(this);
    }
    getExpression(varName) {
      if (varName == null) dart.nullFailed(I[5], 44, 35, "varName");
      if (dart.test(this.variables[$containsKey](varName))) {
        return dart.nullCheck(this.variables[$_get](varName));
      }
      if (this.parentScope != null) {
        return dart.nullCheck(this.parentScope).getExpression(varName);
      } else {
        dart.throw(new core.StateError.new("Variable not bound: " + dart.str(varName)));
      }
    }
    getFunction(name) {
      if (name == null) dart.nullFailed(I[5], 60, 35, "name");
      let candidates = this.functions[$where](dart.fn(mathFunction => {
        if (mathFunction == null) dart.nullFailed(I[5], 62, 26, "mathFunction");
        return mathFunction.name == name;
      }, T.MathFunctionTobool()));
      if (dart.test(candidates[$isNotEmpty])) {
        return candidates[$first];
      } else if (this.parentScope != null) {
        return dart.nullCheck(this.parentScope).getFunction(name);
      } else {
        dart.throw(new core.StateError.new("Function not bound: " + dart.str(name)));
      }
    }
    bindVariable(v, e) {
      if (v == null) dart.nullFailed(I[5], 74, 30, "v");
      if (e == null) dart.nullFailed(I[5], 74, 44, "e");
      this.variables[$_set](v.name, e);
    }
    bindVariableName(vName, e) {
      if (vName == null) dart.nullFailed(I[5], 79, 32, "vName");
      if (e == null) dart.nullFailed(I[5], 79, 50, "e");
      this.variables[$_set](vName, e);
    }
    unbindVariableName(vName) {
      if (vName == null) dart.nullFailed(I[5], 84, 34, "vName");
      this.variables[$remove](vName);
    }
    bindFunction(f) {
      if (f == null) dart.nullFailed(I[5], 89, 34, "f");
      this.functions.add(f);
    }
    toString() {
      return "ContextModel[" + "PARENT: " + dart.str(this.parentScope) + ", " + "VARS: " + dart.str(dart.toString(this.variables)) + ", " + "FUNCS: " + dart.str(dart.toString(this.functions)) + "]";
    }
  };
  (math_expressions.ContextModel.new = function() {
    this[variables] = new (T.IdentityMapOfString$Expression()).new();
    this[functions] = T.LinkedHashSetOfMathFunction().new();
    this[parentScope$] = null;
    ;
  }).prototype = math_expressions.ContextModel.prototype;
  (math_expressions.ContextModel._child = function(parentScope) {
    this[variables] = new (T.IdentityMapOfString$Expression()).new();
    this[functions] = T.LinkedHashSetOfMathFunction().new();
    this[parentScope$] = parentScope;
    ;
  }).prototype = math_expressions.ContextModel.prototype;
  dart.addTypeTests(math_expressions.ContextModel);
  dart.addTypeCaches(math_expressions.ContextModel);
  dart.setMethodSignature(math_expressions.ContextModel, () => ({
    __proto__: dart.getMethods(math_expressions.ContextModel.__proto__),
    createChildScope: dart.fnType(math_expressions.ContextModel, []),
    getExpression: dart.fnType(math_expressions.Expression, [core.String]),
    getFunction: dart.fnType(math_expressions.MathFunction, [core.String]),
    bindVariable: dart.fnType(dart.void, [math_expressions.Variable, math_expressions.Expression]),
    bindVariableName: dart.fnType(dart.void, [core.String, math_expressions.Expression]),
    unbindVariableName: dart.fnType(dart.void, [core.String]),
    bindFunction: dart.fnType(dart.void, [math_expressions.MathFunction])
  }));
  dart.setLibraryUri(math_expressions.ContextModel, I[1]);
  dart.setFieldSignature(math_expressions.ContextModel, () => ({
    __proto__: dart.getFields(math_expressions.ContextModel.__proto__),
    parentScope: dart.fieldType(dart.nullable(math_expressions.ContextModel)),
    variables: dart.fieldType(core.Map$(core.String, math_expressions.Expression)),
    functions: dart.fieldType(core.Set$(math_expressions.MathFunction))
  }));
  dart.defineExtensionMethods(math_expressions.ContextModel, ['toString']);
  dart.trackLibraries("packages/math_expressions/math_expressions.dart", {
    "package:math_expressions/math_expressions.dart": math_expressions
  }, {
    "package:math_expressions/math_expressions.dart": ["src/algebra.dart", "src/expression.dart", "src/functions.dart", "src/parser.dart", "src/evaluator.dart"]
  }, '{"version":3,"sourceRoot":"","sources":["src/algebra.dart","src/expression.dart","src/functions.dart","src/parser.dart","src/evaluator.dart"],"names":[],"mappings":"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","file":"../../../../../../../../../../packages/math_expressions/math_expressions.dart.lib.js"}');
  // Exports:
  return {
    math_expressions: math_expressions
  };
}));

//# sourceMappingURL=math_expressions.dart.lib.js.map
